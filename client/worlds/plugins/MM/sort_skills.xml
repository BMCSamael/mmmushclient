<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, August 21, 2012, 11:19 AM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "sort_skills" generated by Plugin Wizard -->

<muclient>

<plugin
   name="sort_skills"
   author="Ruthgul"
   id="da9c885cd98fd213dd8f719a"
   language="Lua"
   purpose="shows your skills/spells sorted alphabetically, with notes"
   save_state="y"
   date_written="2012-08-21 10:08:10"
   date_modified="2014-11-06 10:19:26"
   requires="4.71"
   version="1.0"
   >

<description trim="y">

<![CDATA[

.---------------.
 | sort_skills |
`---------------'

Lets you sort your lists of skills and spells, and add "wanted learned%" notes.


** REQUIRES **

- MM_GMCP_Handler (plugin id="f67c4339ed0591a5b010d05b") must be installed and enabled.
- detect_globals (plugin id="d900cb999816b1f6f2d4bdc5") must be installed and enabled.
- global_vars (plugin id="97784abf5f30629a0d7e7307") must be installed and enabled.


Syntax:

* sort skills [on|off]  - enables/disables the "sort list" script (on by default)

* skills show hyperlinks [on|off]  - show/hide hyperlinks (underlines) for skills names (on by default)

* skills addhint s:<skill_name> h:<hint>  - adds a "wanted lrnd%" hint for the skill
  (eg: skills addhint s:lore h:100%)

* skills delhint s:<skill_name>  - deletes a "wanted lrnd%" hint for the skill
  (eg: skills delhint s:kick)


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Aliases  -->

<aliases>

  <alias
   match="^sort[ ]+skills(|[ ]+(?P&lt;state&gt;(on|off)))$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>toggle_sort("%&lt;state&gt;")
</send>
  </alias>

  <alias
   match="^skills[ ]+show[ ]+hyperlinks(|[ ]+(?P&lt;state&gt;(on|off)))$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>toggle_hyperlinks("%&lt;state&gt;")
</send>
  </alias>

  <alias
   match="^skills[ ]+addhint[ ]+s\:(?P&lt;name&gt;.+)[ ]+h\:(?P&lt;hint&gt;[0-9]+)(|\%)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) and (thints) then
  add_hint("%&lt;name&gt;", "%&lt;hint&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   match="^skills[ ]+delhint[ ]+s\:(?P&lt;name&gt;.+)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) and (thints) then
  del_hint("%&lt;name&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   match="^show skill help (?P&lt;name&gt;.+)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>show_skill_help("%&lt;name&gt;")
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^sort\_skills(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Triggers  -->

<triggers>

<!-- on first prompt -->

  <trigger
   enabled="y"
   name="first_prompt"
   keep_evaluating="y"
   match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)|\&gt;) $"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>on_first_prompt()
</send>
  </trigger>


<!-- generic -->

  <trigger
   name="continue"
   keep_evaluating="y"
   match="^\[C\]ontinue \[R\]edraw \[B\]ack \[E\]xit\: $"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>auto_cont()
</send>
  </trigger>


<!-- proficiencies -->

  <trigger
   name="start_profs"
   group="(p)"
   keep_evaluating="y"
   match="^\[ \# \] \[[ ]+Proficiency Name[ ]+\] \[ Type \] \[ Cmplx \] \[ Lrnd \]$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>sort_profs_start()
</send>
  </trigger>

  <trigger
   name="capture_profs"
   group="(p)"
   keep_evaluating="y"
   match="^(.+)$"
   regexp="y"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
sort_profs_line("%0")
</send>
  </trigger>

  <trigger
   name="end_profs"
   group="(p)"
   keep_evaluating="y"
   match="^Color Key\: \[Active\] \[Inactive\] \[Altered \+\] \[Altered \-\] \[Unavailable\]$"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
sort_profs_end()
</send>
  </trigger>


<!-- spells -->

  <trigger
   name="start_spells"
   group="(s)"
   keep_evaluating="y"
   match="^\[ \# \] \[[ ]+Spell Name[ ]+\] \[ School \] \[ SP \] \[ Cmplx \] \[ Lrnd \]$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>sort_spells_start("%0")
</send>
  </trigger>

  <trigger
   name="capture_spells"
   group="(s)"
   keep_evaluating="y"
   match="^(.+)$"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
sort_spells_line("%0")
</send>
  </trigger>

  <trigger
   name="end_spells"
   group="(s)"
   keep_evaluating="y"
   match="^(Color Key\: \[Active\] \[Inactive\] \[Altered \+\] \[Altered \-\] \[Unavailable\]|You are not learned in any magical spells\.)$"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
sort_spells_end()
</send>
  </trigger>


<!-- on 'next' prompt -->

  <trigger
   name="a_prompt"
   keep_evaluating="y"
   match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)|\&gt;) $"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>on_next_prompt()
</send>
  </trigger>

</triggers>



<!--  Scripts  -->

<script>

<![CDATA[

require "wait"
require "gmcphelper"


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
  ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
  Note(" to see info about this plugin --")

  load_config()

  -- open database on disk
  db = assert(sqlite3.open(GetInfo(66) .. "skills.db"))

  create_table()    -- create database structure if necessary

  EnableTrigger("first_prompt", true)
  EnableTrigger("a_prompt", false)
  name = nil
end


function OnPluginConnect()
  EnableTrigger("first_prompt", true)
  EnableTrigger("a_prompt", false)
  name = nil

  EnableTrigger("start_profs", false)
  EnableTrigger("start_spells", false)
end


function OnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID (), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo (GetPluginID(), 14)) .. ")")
end


function plugin_not_initialized()
  Note("-- " .. GetPluginInfo(GetPluginID (), 1) .. ": plugin initialization unfinished --")
  Note("please wait 5 seconds and try again")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/sort_skills.xml",
  }
  return (table.concat(t, ";"))
end



------------------
-- general stuff
------------------

function on_first_prompt()
  wait.make(function()
    EnableTrigger("first_prompt", false)

    -- give the plugins time to initialize
    wait.time(3)

    do_get_name()
  end)
end


function OnPluginBroadcast(msg, id, pname, text)
  if (id =="f67c4339ed0591a5b010d05b") then -- GMCP message
    if (text == "room.info") then -- room.info
      get_gmcp_room()
    end

  elseif (id =="97784abf5f30629a0d7e7307")
  and (pname == "global_vars") then -- global_vars
    if (msg == 1) and (text == "name") then
      -- name broadcasted
      do_get_name()
    end
  end
end


function do_get_name()
  name = get_global_var("name")

  if (name) then
    got_name()
  end
end


function get_global_var(name)
  local res, val

  res, val = CallPlugin("97784abf5f30629a0d7e7307", "get_global_var", name)

  if (res ~= 0) then
    val = nil
  end

  return val
end


function got_name()
  load_tables()
end


function auto_cont()
  SendNoEcho("C")
end



---------------------------
-- TriggerStyleRuns stuff
---------------------------

function show_original_line()
  for i = 1, #trigger_style_runs do
    ColourTell(RGBColourToName(trigger_style_runs[i].textcolour),
               RGBColourToName(trigger_style_runs[i].backcolour),
               trigger_style_runs[i].text)
  end

  Note("")
end


function capture_colors()
  black = RGBColourToName(trigger_style_runs[1].backcolour)
  silver = RGBColourToName(trigger_style_runs[1].textcolour)
  yellow = RGBColourToName(trigger_style_runs[3].textcolour)
  olive = RGBColourToName(trigger_style_runs[5].textcolour)
  lime = RGBColourToName(trigger_style_runs[7].textcolour)
  red = RGBColourToName(trigger_style_runs[9].textcolour)
  gray = RGBColourToName(trigger_style_runs[11].textcolour)
end



------------
-- toggles
------------

function toggle_sort(status)
  config.show_sorted = do_toggle(config.show_sorted, status)

  save_config()

  if (config.show_sorted) then
    Note("-- sort_skills: will now sort your skills/spells alphabetically --")

  else
    Note("-- sort_skills: will no longer sort your skills/spells --")
  end
end


function toggle_hyperlinks(status)
  config.show_hyperlinks = do_toggle(config.show_hyperlinks, status)

  save_config()

  if (config.show_hyperlinks) then
    Note("-- sort_skills: will now show hyperlinks for skills --")

  else
    Note("-- sort_skills: will no longer show hyperlinks for skills --")
  end
end


function do_toggle(var, status)
  if (status == "on") then
    var = true
  elseif (status == "off") then
    var = false
  else
    var = not var
  end

  return var
end


function load_config()
  config = {
    show_sorted = ((GetVariable("show_sorted") or "true") == "true"),
    show_hyperlinks = ((GetVariable("show_hyperlinks") or "true") == "true"),
  }
end


function save_config()
  SetVariable("show_sorted", tostring(config.show_sorted))
  SetVariable("show_hyperlinks", tostring(config.show_hyperlinks))

  SaveState()
end



-----------------------
-- sort proficiencies
-----------------------

function sort_profs_start()
  EnableTrigger("capture_profs", true)
  EnableTrigger("end_profs", true)
  EnableTrigger("continue", true)
  tprofs = {}
end


function sort_profs_line(line)
  if (not string.find(line, "Color Key:"))
  and (string.find(line, "ontinue") ~= 4) then
--    for i = 1, #trigger_style_runs do
--      Tell("#" .. i .. " - ")
--      Tell(RGBColourToName(trigger_style_runs[i].textcolour) .. " - ")
--      Note(Trim(trigger_style_runs[i].text))
--    end

    local pnum = Trim(trigger_style_runs[1].text)

    local pname = Trim(trigger_style_runs[2].text)
    local pcolor = RGBColourToName(trigger_style_runs[2].textcolour)

    local ptype = Trim(trigger_style_runs[4].text)
    magenta = RGBColourToName(trigger_style_runs[4].textcolour)

    local pcmplx = Trim(trigger_style_runs[5].text)

    local plrnd = Trim(string.match(trigger_style_runs[6].text, "%d+"))

    local srecom
    if (trigger_style_runs[7]) then
      srecom = Trim(trigger_style_runs[7].text)
    else
      srecom = ""
    end

--    show_original_line()

    tprofs[#tprofs + 1] = pname .. ";" .. pcolor .. ";" .. pnum .. ";" .. ptype .. ";" .. pcmplx .. ";" .. plrnd .. ";" .. srecom

  elseif (string.find(line, "Color Key:")) then
  -- capture colors from the color key line, in case they're non-standard
    capture_colors()
  end
end


function sort_profs_end()
  EnableTrigger("capture_profs", false)
  EnableTrigger("end_profs", false)
  EnableTrigger("continue", false)

  if (config.show_sorted) then
    table.sort(tprofs)
  end

--  require "serialize"
--  Note(serialize.save_simple(tprofs))
--  Note("#tprofs: " .. #tprofs)

  local t
  for i = 1, #tprofs do
    t = utils.split(tprofs[i], ";")

    ColourTell(silver, black, string.rep(" ", 4 - string.len(t[3])) .. t[3] .. string.rep(" ", 3))
    if (config.show_hyperlinks) then
      Hyperlink("show skill help " .. t[1], t[1], "", t[2], black, false)
    else
      ColourTell(t[2], black, t[1])
    end
    ColourTell(magenta, black, string.rep(" ", 26 - string.len(t[1])) .. t[4])
    ColourTell(silver, black, string.rep(" ", 10 - string.len(t[5])) .. t[5])
    ColourTell(lime, black, string.rep(" ", 9 - string.len(t[6])) .. t[6] .. "%")

    local showed_hint = false

    if (name) then
      if (thints[t[1]]) then
        if (tonumber(thints[t[1]]) > tonumber(t[6])) then
          ColourTell(silver, black, " / ")
          ColourTell(t[2], black, thints[t[1]] .. "%")
          showed_hint = true

        elseif (tonumber(thints[t[1]]) <= tonumber(t[6])) then
          del_hint(t[1])
        end
      end
    end

    if (t[7] ~= "") and (not showed_hint) then
      ColourTell(magenta, black, " " .. t[7])
    end

    Note("")
  end

  show_original_line()
end


function show_skill_help(skill)
  wait.make(function()
    SendNoEcho("help " .. skill)

    if (mobs_n_items_plugin_present()) then
      Note("")

      if (gmcpdata) then
        local area = gmcpval("zone")
      end

      -- wait for a prompt
      next_prompt = false
      EnableTrigger("a_prompt", true)

      while (not next_prompt) do
        wait.time(.5)
      end

      if (gmcpdata) and (not is_vmap(area)) then
        Execute("skill wheree " .. skill .. " a: " .. area)

      else
        Execute("skill wheree " .. skill)
      end

      Note("")
    end
  end)
end


function mobs_n_items_plugin_present()
  return is_plugin_present("mobs_n_items", "8755063a5cf00f3312b113e6")
end


function is_plugin_present(name, id)
  local res = false

  local plugin_name = GetPluginInfo(id, 1)

  if (plugin_name == name) then
    -- is it enabled?
    if (GetPluginInfo(id, 17)) then
      res = true
    end
  end

  return res
end


function on_next_prompt()
  EnableTrigger("a_prompt", false)

  next_prompt = true
end



---------------
-- gmcp stuff
---------------

function get_gmcp_room()
  local res, gmcparg = CallPlugin("f67c4339ed0591a5b010d05b", "gmcpval", "room.info")
  luastmt = "gmcpdata = " .. gmcparg

  assert(loadstring(luastmt or ""))()
end


function is_vmap(zone)
  local res
  res = ((zone == "Alyria")
      or (zone == "Chat Rooms Wilderness")
      or (zone == "Faerie Plane Wilderness")
      or (zone == "Great Alyrian Underground")
      or (zone == "Lasler Valley")
      or (zone == "Sigil Underground")
      or (zone == "Verity Isle"))
  return res
end



----------------
-- sort spells
----------------

function sort_spells_start()
  EnableTrigger("capture_spells", true)
  EnableTrigger("end_spells", true)
  EnableTrigger("continue", true)
  tspells = {}
end


function sort_spells_line(line)
  if (not string.find(line, "Color Key:"))
  and (not string.find(line, "You are not learned in any magical spells."))
  and (string.find(line, "ontinue") ~= 4) then
--    for i = 1, #trigger_style_runs do
--      Tell("#" .. i .. " - ")
--      Tell(RGBColourToName(trigger_style_runs[i].textcolour) .. " - ")
--      Note(Trim(trigger_style_runs[i].text))
--    end

    local snum, sname, scolor, sschool, ssp, scmplx, slrnd, srecom

    if (trigger_style_runs[2]) then
      snum = Trim(trigger_style_runs[1].text)

      sname = Trim(trigger_style_runs[2].text)
      scolor = RGBColourToName(trigger_style_runs[2].textcolour)

      sschool = Trim(trigger_style_runs[4].text)
      magenta = RGBColourToName(trigger_style_runs[4].textcolour)

      ssp = Trim(trigger_style_runs[6].text)
      white = RGBColourToName(trigger_style_runs[6].textcolour)

      scmplx = Trim(trigger_style_runs[7].text)

      slrnd = Trim(string.match(trigger_style_runs[8].text, "%d+"))

      if (trigger_style_runs[9]) then
        srecom = Trim(trigger_style_runs[9].text)
      else
        srecom = ""
      end
    end

--    show_original_line()

    if (snum) and (sname) and (scolor) and (sschool) and (ssp) and (scmplx) and (slrnd) and (srecom) then
      tspells[#tspells + 1] = sname .. ";" .. scolor .. ";" .. snum .. ";" .. sschool .. ";" .. ssp .. ";" .. scmplx .. ";" .. slrnd .. ";" .. srecom
    end

  elseif (string.find(line, "Color Key:")) then
  -- capture colors from the color key line, in case they're non-standard
    capture_colors()
  end
end


function sort_spells_end()
  EnableTrigger("capture_spells", false)
  EnableTrigger("end_spells", false)
  EnableTrigger("continue", false)

  if (config.show_sorted) then
    table.sort(tspells)
  end

--  require "serialize"
--  Note(serialize.save_simple(tprofs))
--  Note("#tspells: " .. #tspells)

  local t
  for i = 1, #tspells do
    t = utils.split(tspells[i], ";")

    ColourTell(silver, black, string.rep(" ", 4 - string.len(t[3])) .. t[3] .. string.rep(" ", 3))
    if (config.show_hyperlinks) then
      Hyperlink("show skill help " .. t[1], t[1], "", t[2], black, false)
    else
      ColourTell(t[2], black, t[1])
    end
    ColourTell(magenta, black, string.rep(" ", 25 - string.len(t[1])) .. t[4])
    ColourTell(white, black, string.rep(" ", 10 - string.len(t[5])) .. t[5])
    ColourTell(silver, black, string.rep(" ", 8 - string.len(t[6])) .. t[6])
    ColourTell(lime, black, string.rep(" ", 9 - string.len(t[7])) .. t[7] .. "%")

    local showed_hint = false

    if (name) then
      if (thints[t[1]]) then
        if (tonumber(thints[t[1]]) > tonumber(t[7])) then
          ColourTell(silver, black, " / ")
          ColourTell(t[2], black, thints[t[1]] .. "%")
          showed_hint = true

        elseif (tonumber(thints[t[1]]) <= tonumber(t[7])) then
          del_hint(t[1])
        end
      end
    end

    if (t[8] ~= "") and (not showed_hint) then
      ColourTell(magenta, black, " " .. t[8])
    end

    Note("")
  end

  show_original_line()
end



----------------
-- hints stuff
----------------

function load_tables()
  thints = {}

  for row in db:nrows(string.format("SELECT * FROM hints WHERE char_name = %s", fixsql(name))) do
    thints[row.skill_name] = row.hint
  end

  EnableTrigger("start_profs", true)
  EnableTrigger("start_spells", true)
end


function add_hint(skill, hint)
  if (not thints) then
    thints = {}
  end

  thints[skill] = hint

--  require "serialize"
--  Note(serialize.save_simple(thints))

  db_save_hint(skill, hint)

  Note("")
  Tell("-- sort_skills: added hint for skill '")
  ColourTell("silver", "black", skill)
  Note("' --")
end


function del_hint(skill)
  if (not thints) then
    thints = {}
  end

  if (thints[skill]) then
    thints[skill] = nil

    db_delete_hint(skill)

    Note("")
    Tell("-- sort_skills: deleted hint for skill '")
    ColourTell("silver", "black", skill)
    Note("' --")

  else
    Tell("-- sort_skills: can't remove nonexistent hint for skill '")
    ColourTell("silver", "black", skill)
    Note("' --")
  end

--  require "serialize"
--  Note(serialize.save_simple(thints))
end



-------------------
-- database stuff
-------------------

function dbcheck(code)
 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg()   -- the rollback will change the error message
    db:exec("ROLLBACK")       -- rollback any transaction to unlock the database
    error(err, 2)             -- show error in caller's context
  end
end


function fixsql(s)
  if s then
    return "'" .. (string.gsub(s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end
end


function create_table()
  -- create table
  dbcheck(db:execute[[
    PRAGMA foreign_keys = ON;
    PRAGMA journal_mode = WAL;

    CREATE TABLE IF NOT EXISTS hints(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      char_name     TEXT NOT NULL,   -- character name
      skill_name    TEXT NOT NULL,   -- skill name
      hint          INTEGER,         -- hint
      date_added    INTEGER
    );
 ]])
end



---------------
-- load hint
---------------

function load_hint_from_database(skill)
  local hint

  for row in db:nrows(string.format("SELECT * FROM hints WHERE char_name = %s AND skill_name = %s ", fixsql(name), fixsql(skill))) do
    hint = row.hint
  end

  return hint
end


--------------
-- save hint
--------------

function db_save_hint(skill, hint)
  local oldhint = load_hint_from_database(skill)

  if (not oldhint) then
    save_hint_to_database(skill, hint)

  else
    update_hint_database_info(skill, hint)
  end
end


function save_hint_to_database(skill, hint)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "INSERT INTO hints(char_name, skill_name, hint, date_added) VALUES(%s, %s, %i, DATETIME('NOW'));",
      fixsql(name),
      fixsql(skill),
      hint
  )))

  db:exec("COMMIT;")
end



----------------
-- update hint
----------------

function update_hint_database_info(skill, hint)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "UPDATE hints SET hint = %i, date_added = DATETIME('NOW') WHERE char_name = %s AND skill_name = %s;",
      hint,
      fixsql(name),
      fixsql(skill)
  )))

  db:exec("COMMIT;")
end



----------------
-- delete hint
----------------

function db_delete_hint(skill)
  local hint = load_hint_from_database(skill)

  if (hint) then
    delete_hint_from_database(skill)
  end
end


function delete_hint_from_database(skill)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format([[
    DELETE FROM hints WHERE char_name = %s AND skill_name = %s;
  ]], fixsql(name), fixsql(skill)
      )))

  db:exec("COMMIT;")
end


]]>

</script>

</muclient>
