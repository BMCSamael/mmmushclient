<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, August 02, 2010, 2:17 PM -->
<!-- MuClient version 4.51 -->
<!-- Plugin "GMCPHandler" generated by Plugin Wizard -->

<muclient>

<plugin
   name="MM_GMCP_handler"
   author="Lasher, Ruthgul"
   id="f67c4339ed0591a5b010d05b"
   language="Lua"
   purpose="Handle GMCP messages and broadcast data"
   save_state="y"
   date_written="2011-10-17 17:59:26"
   date_modified="2014-11-22 12:52:59"
   requires="4.61"
   version="1.0"
   sequence="100"
  >

<description trim="y">

<![CDATA[

.-------------------.
 | MM_GMCP_handler |
`-------------------'

Materia Magica GMCP Handler.
Based on Aardwolf GMCP Handler, by Lasher.
Adapted by Ruthgul to work on Materia Magica.


IMPORTANT:

- The file gmcphelper.lua must be placed in the MUSHclient/lua directory.

- You need to re-login to Materia Magica after you install this plugin.

- After you re-login, use the commands
    protocols
    protocols gmcp
  to be sure that it's working properly.

(See _detailed instructions_ on the plugin's homepage.)


~~ Original Aardwolf plugin info: ~~

Aardwolf GMCP Handler, by Lasher.

Purpose is to receive incoming GMCP messages and populate the global
table 'gmcpdata' with the values as received so that GMCP under Mushclient
can use partial refreshes of data. For example, we might receive:

   char.vitals { "hp": 100000, "mana": 90000, "moves": 41599 }

Then next time, if only HP and Mana have changed, receive:

   char.vitals { "hp": 100000, "mana": 85000 }

The previous value for 'moves' will be remembered and available until
it is refreshed.

~~ end ~~


Authors: Lasher, Ruthgul (maintained by Ruthgul)

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>

<aliases>
  <alias
   script="gmcpdebug"
   match="^gmcpdebug (.+)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   ignore_case="y"
  >
  </alias>

  <alias
   match="sendgmcp *"
   script="GMCP_Alias"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   enabled="n"
   match="gmcp simulate"
   script="GMCP_simulate"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   match="^showgmcpval (?P&lt;what&gt;.+?)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>local aux = gmcpval("%&lt;what&gt;")
Note("%&lt;what&gt;: " .. aux)
</send>
  </alias>

  <alias
    enabled="y"
    ignore_case="y"
    match="^(|MM\_)GMCP(|\_Handler)(|( |\:)help)$"
    regexp="y"
    script="OnHelp"
  >
  </alias>
</aliases>



<!--  Get our standard constants -->

<script>

<![CDATA[

require "json"
require "serialize"
require "gmcphelper"

local IAC, SB, SE, DO = 0xFF, 0xFA, 0xF0, 0xFD
local GMCP      = 201
local GMCPDebug = 0


function gmcpdebug(name, line, wildcards)
  newval = tonumber(wildcards[1])
  if not newval or newval > 2 or newval < 0 then
    ColourNote("darkorange", "", "GMCPDebug valid values are: 0 - off, 1 - simple, 2 - verbose")
    return
  end
  GMCPDebug = newval
  local msg = "off"
  if GMCPDebug == 1 then
    msg = "simple"
  elseif GMCPDebug == 2 then
    msg = "verbose"
  end
  ColourNote("darkorange", "", "GMCPDebug: " .. msg)
end


function GMCP_Alias(name, line, wildcards)
  if (wildcards[1]) then
--    Send_GMCP_Packet(wildcards[1]) -- in gmcphelper
    Send_GMCP_Packet(wildcards[1] .. ' {"":""}') -- in gmcphelper -- MM fix: requires {"":""}
  end
end


function GMCP_simulate(name, line, wildcards)
  local data = [[char.gecho_notification {"gecho_msg": "\n\r\n\r|WTEST TEST TEST|X\n\r\n\r"}]]

  OnPluginTelnetSubnegotiation(GMCP, data)
end



------------------------------------------------------------------------------------------------
-- Mushclient callback function when telnet SB data received.
------------------------------------------------------------------------------------------------
function OnPluginTelnetSubnegotiation(msg_type, data)
  if msg_type ~= GMCP then
    return
  end -- if not GMCP

  if (GMCPDebug > 0) then
    Note(data)
  end

  data = string.gsub(data, "&quot;", string.char(34)) -- MM fix

  -- send data to sandbox to update online map
  -- This code is to interface with Ardant's MagicMap.
  -- It will do nothing if you haven't installed & opened the sandbox.dune.net worldfile.
  local dune_net = GetWorld("sandbox.dune.net")
  if (dune_net ~= nil) then
    if ((string.find(data, "char.base", 0, true))
    or (string.find(data, "room.info", 0, true))) then
--      Note("sending data")
      Send(dune_net, data)
    end
  end

  -- if it's an info package
--  if ((string.find(data, "char.", 0, true))
--  or (string.find(data, "room.info", 0, true))) then
--    message, params = string.match(data, "([%a.]+)%s+(.*)") --original
    message, params = string.match(data, "([%a%d%-%_%.]+)%s+(.*)") -- MM fix: regex

    if (GMCPDebug > 1) then
      Note("message: " .. message)
      Note("params: " .. params)
    end

    if not message then
      return
    end -- if

    if not string.match(params, "^[%[{]") then
      params =  "[" .. params .. "]"  -- JSON hack, make msg first element of an array.
    end -- if

--    local t = json.decode(params)
    local succ, t = pcall(json.decode, params) -- update

    if (GMCPDebug > 1) then
      Note("json.decode(params) serialized: " .. serialize.save_simple(t))
    end

--    if type(t) == "table" then
    if succ and type(t) == "table" then -- update
      gmcpdata = gmcpdata or {}

      -- Create the higher level tables based on tag such as char.vitals or room.info etc.
      -- Lowest level of those wlil be the 'parent' for parse_gmcp
      local parent = gmcpdata
--      for item in string.gmatch(message,"%a+") do
      for item in string.gmatch(message, "[%a%d%-%_]+") do -- MM fix: regex
        -- reset data hacks
--        if (item == "room") or (item == "comm") then
         if (item == "room" and message:sub(1,13) ~= "room.wrongdir") -- update
         -- don't let room.wrongdir erase current room info
         or item == "comm" or item == "group" then

          parent[item] = nil
        end

        parent[item] = parent[item] or {}
        parent = parent[item]
      end

      parse_gmcp(t, nil, parent)

      if (GMCPDebug > 1) then
        Note("gmcpdata serialized: " .. serialize.save_simple(gmcpdata))
--        Note("parent serialized: " .. serialize.save_simple(parent))
      end

      BroadcastPlugin(1, message)

      -- Examples of use from here on. Can be uncommented for debug.
      --print("Testing room.info.exits table      : " .. gmcpval("room.info.exits")) -- serialized table.
      --print("Testing correct room name          : " .. gmcpval("room.info.brief")) -- single field
      --print("Testing character str stat         : " .. gmcpval("char.stats.str"))  -- single number.
      --print("Testing top-level value            : " .. gmcpval("char"))            -- all char table.
      --print("Testing bad top-level value        : " .. gmcpval("sdlkfsldf"))       -- nil (not error)
      --print("Testing bad lower level            : " .. gmcpval("blah.1.2.3"))      -- nil
      --print("Testing bad lower level inside good: " .. gmcpval("room.info.hinick")) -- nil
      --print("Testing north exit, deeper nest    : " .. gmcpval("room.info.exits.n"))
      -- End of test cases.

    else -- update
      ColourNote("white", "red", "GMCP DATA ERROR: " .. t) -- update
    end -- if
--  end
end -- function OnPluginTelnetSubnegotiation


function OnPluginInstall()
  Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
  ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
  Note(" to see info about this plugin --")

  BroadcastPlugin(1, "reload") -- reload basically tells other plugins "clear all your gmcp data"
end


function OnPluginTelnetRequest(msg_type, data)
  if msg_type == GMCP and data == "WILL" then
    return true
  end -- if

  if msg_type == GMCP and data == "SENT_DO" then
    Note("Enabling GMCP.")
    -- This hard-coded block may need to be made into a config table as we add more message types.
    Send_GMCP_Packet(string.format('Core.Hello { "client": "MUSHclient", "version": "%s" }', Version()))
    Send_GMCP_Packet('Core.Supports.Set [ "Char 1", "Comm 1", "Room 1", "Core 1", "IRE.Composer 1" ]')
    return true
  end -- if GMCP login needed (just sent DO)

  return false

end -- function OnPluginTelnetRequest


------------------------------------------------------------------------------------------------
-- FUNCTION:: init_gmcpdata
--    Performs 2 functions:
--       1. Define a table of tags we support, including refreshed tags (clear each time) and
--          regular tags.
--       2. Initialize gmcpdata to have empty tables nested at these levels.
------------------------------------------------------------------------------------------------

function init_gmcpdata()
   --- Not used yet, placeholder to replace room reset data hack with a table.
end -- init_gmcpdata


------------------------------------------------------------------------------------------------
-- FUNCTION:: parse_gmcp
--   Receives a set of JSON data and a parent to store its table into. Will recursively call
--   itself building up the levels of, for example, gmcpdata.room.info.exits.n as it goes.
------------------------------------------------------------------------------------------------

function parse_gmcp(t, done, parent)
  -- MM fix: changed these to fail silently, or show debug msgs if applicable

--  assert(t, "nil table passed to parse_gmcp")
--  assert(parent, "nil parent passed to parse_gmcp")
--  assert(type (t) == "table",  "non-table value passed to parse_gmcp")
--  assert(type (parent) == "table", "non-table parent value passed to parse_gmcp")

  if (t)
  and (parent)
  and (type(t) == "table")
  and (type(parent) == "table") then

    local function parseone(val)
      if type (val) == "string" then
        return val
      elseif type(val) == "function" then
        return nil
      else
        return tostring(val)
      end
    end -- parseone

    done = done or {}

    for key, value in pairs(t) do
      if type (value) == "table" and not done[value] then
        parent[key] = parent[key] or { }
        done [value] = true
        parse_gmcp(value, done, parent[key])
      else
        parent[key] = parseone(value) -- might be able to remove last parameter.
      end
    end -- for

  else
    if (GMCPDebug > 0) then
      if (not t) then
        Note("-- " .. GetPluginInfo(GetPluginID(), 3) .. "nil table passed to parse_gmcp() --")
      end
      if (not parent) then
        Note("-- " .. GetPluginInfo(GetPluginID(), 3) .. "nil parent passed to parse_gmcp() --")
      end
      if (type(t) ~= "table") then
        Note("-- " .. GetPluginInfo(GetPluginID(), 3) .. "non-table value passed to parse_gmcp() --")
      end
      if (type(parent) ~= "table") then
        Note("-- " .. GetPluginInfo(GetPluginID(), 3) .. "non-table parent value passed to parse_gmcp() --")
      end
    end
  end
end -- parse_gmcp function



---------
-- help
---------

function OnHelp()
  ColourNote("silver", "black", GetPluginInfo(GetPluginID(), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo(GetPluginID(), 14)) .. ")")
end


-----------
-- update
-----------

function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/MM_GMCP_handler.xml",
  }
  return (table.concat(t, ";"))
end


function plugin_update_aux_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/gmcphelper.lua,MUSH/lua",
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/res/sandbox.dune.net.MCL,MUSH/worlds",
  }
  return (table.concat(t, ";"))
end


]]>

</script>

</muclient>
