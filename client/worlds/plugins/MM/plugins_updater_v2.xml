<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, July 20, 2012, 11:31 AM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "plugins_updater_v2" generated by Plugin Wizard -->

<!--

Note for developers: For a plugin to be "supported", it must have a public function like this:

function plugin_update_url()
  local t = {
    "http://mysite.org/directory/file.xml",
  }
  return (table.concat(t, ";"))
end

* the function must be called plugin_update_url()
* the function must return a list of URLs
  (actually, a list with only 1 element: the plugin's .xml file)
* a <url> is separated from the next by a semicolon


Additionally, if the plugin uses "auxiliary" files, it must have a public function like this:

function plugin_update_aux_url()
  local t = {
    "http://mysite.org/directory/image.png",
    "http://mysite.org/directory/database.db,MUSH",
    "http://mysite.org/directory/module.lua,MUSH/lua",
  }
  return (table.concat(t, ";"))
end

* the function must be called plugin_update_aux_url()
* the function must return a list of URLs + optionally the local path to place them
* a <url> is separated from its <local_folder> by a comma - <local_folder> is optional
* each <url>[,<local_folder>] is separated from the next by a semicolon

In the example function:
* t is a table containing a list of URLs of files to be downloaded
* each entry in the t table has this format: <url>[,<local_folder>]
* if <local_folder> is not specified, the file will be placed in the same directory as the plugin
* if <local_folder> starts with MUSH/, it will be expanded to the MUSHclient directory

-->

<muclient>

<plugin
   name="plugins_updater_v2"
   author="Ruthgul"
   id="fbd5b7cc1ef6acf827a3f4a1"
   language="Lua"
   purpose="updates plugins"
   date_written="2012-07-20 11:30:15"
   date_modified="2017-03-19 18:05:36"
   requires="4.71"
   version="2.0"
   >

<description trim="y">

<![CDATA[

.----------------------.
 | plugins_updater_v2 |
`----------------------'

Downloads and installs updated plugins.


** REQUIRES **

- The file llthreads2.dll must be placed in the MUSHclient directory.
- The file ssl.dll must be placed in the MUSHclient directory.
- The file ssl.lua must be placed in the MUSHclient/lua directory.
- The file https.lua must be placed in the MUSHclient/lua/ssl directory.
- The file async.lua must be placed in the MUSHclient/lua directory.


Syntax:

* update plugins  - checks for available updates for installed plugins, then shows hyperlinks to update the outdated ones plus their auxiliary files

* update plugin <partial_name>  - builds a list of installed plugins matching <partial_name>, then shows a hyperlinks to update the supported ones plus their auxiliary files - eg, update plugin mapper

* update plugins lastlist  - updates all the plugins in the last list showed by update plugins or update plugin <partial_name>

* update plugin <id>  - updates the specified plugin plus its auxiliary files, by PluginID


Plugin created by Ruthgul
HTTPS supported via LuaSec
Threads supported via llthreads2
Async code by Fiendish


Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>


<!--  Aliases  -->

<aliases>

  <alias
   group="plugins_updater"
   enabled="y"
   match="^update plugin (?P&lt;id&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>update_plugin("%&lt;id&gt;")
</send>
  </alias>

  <alias
   group="plugins_updater"
   enabled="y"
   match="^update plugins$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>detect_updates()
</send>
  </alias>

  <alias
   group="plugins_updater"
   enabled="y"
   match="^update plugins lastlist$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>update_plugins_lastlist()
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^plugins\_updater(|\_v2)(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>
</aliases>



<!--  Timers  -->

<timers>

  <timer
    enabled="y"
    active_closed="y"
    hour="3"
    second="0.00"
    offset_second="0.00"
    send_to="12"
  >
  <send>detect_updates_if_idling()
</send>
  </timer>

  <timer
    active_closed="y"
    name="get_files_timer"
    second="0.5"
    offset_second="0.00"
    send_to="12"
  >
  <send>check_if_ready_to_get_file()
</send>
  </timer>

</timers>


<!--  Scripts  -->

<script>

<![CDATA[

require "gmcphelper"


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
  ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
  Note(" to see info about this plugin --")

  async_ok, async = pcall(require, "async")

  thread = nil
  last_command = os.time()

  detect_updates()
end


function OnPluginCommand(sText)
  last_command = os.time()
  return true -- process the command
end


function OnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID(), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo(GetPluginID(), 14)) .. ")")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/plugins_updater_v2.xml",
  }
  return (table.concat(t, ";"))
end


function plugin_update_aux_url()
  local t = {
--    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/dll/llthreads.dll,MUSH",
--    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/dll/ssl.dll,MUSH",
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/async.lua,MUSH/lua",
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/ssl.lua,MUSH/lua",
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/https.lua,MUSH/lua/ssl",
  }
  return (table.concat(t, ";"))
end



-------------------
-- detect updates
-------------------

updates_url = "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/text/plugins_versions.txt"


function detect_updates()
  Note("-- plugins_updater_v2: checking for updates... --")
  get_file(updates_url, process_updates_list, do_nothing, {})
end


require "serialize"

function process_updates_list(page)
-- this will be called by get_file, once it's done downloading,
-- if the download was successful

  if (page) then
    EnableAliasGroup("plugins_updater", false)
    G_tlatest = {}

    for line in string.gmatch(page, "[^\r\n]+") do
      local id, hash, aux, name

      aux_files = {}

      if (string.match(line, "^id = (.+)  hash = (.+)  aux_files = (.+)")) then
        id, hash, aux = string.match(line, "^id = (.+)  hash = (.+)  aux_files = (.+)")
        if (aux) then
          assert(loadstring("aux_files = " .. aux))()
        end

      elseif (string.match(line, "^id = (.+)  hash = (.+)")) then
        id, hash = string.match(line, "^id = (.+)  hash = (.+)")

      elseif (string.match(line, "^name = (.+)  hash = (.+)")) then
        name, hash = string.match(line, "^name = (.+)  hash = (.+)")
      end

      if (id) and (hash) then
        G_tlatest[id] = {
          hash = hash,
          taux = aux_files, -- might need copytable.deep() instead
        }
      elseif (name) and (hash) then
        G_tlatest[name] = hash
      end
    end

--    Note(serialize.save_simple(G_tlatest))

    build_updated_plugins_list()
  end
end


function do_nothing()
-- this will be called by get_file, once it's done downloading,
-- if the download failed
end


function build_updated_plugins_list()
  Note("-- plugins_updater_v2: building the list of plugins that have pending updates... --")

  G_tfiles = {}
  G_tplug_keys = {}
  G_taux_keys = {}

  local hash, plug_changed, p_url_path, p_local_path, p_file_name, taux, aux_changed

  if (G_tlatest) then
    for _, id in pairs(GetPluginList()) do
      plug_changed = false

      if (G_tlatest[id]) then
        p_url_path, p_local_path, p_file_name = find_plugin_data(id)

        if (p_url_path) then
          hash = get_file_hash(p_local_path .. p_file_name)
          if (G_tlatest[id].hash) and (G_tlatest[id].hash ~= hash) then
            plug_changed = true
          end

          taux, aux_changed = build_updated_aux_files_list(id, p_url_path, p_local_path)

          for name, tinfo in pairs(taux) do
            G_tfiles[#G_tfiles + 1] = make_file_update_t(nil, name, tinfo.url, tinfo.lpath, tinfo.update)
            G_taux_keys[name] = true
          end

          if (plug_changed) or (aux_changed) then
            taux = make_file_update_t(id, p_file_name, p_url_path, p_local_path, plug_changed)

            G_tfiles[#G_tfiles + 1] = taux
            G_tplug_keys[id] = true
          end
        end
      end
    end

--    Note("G_tfiles: " .. serialize.save_simple(G_tfiles))

    if (#G_tfiles > 0) then
      do_list_plugins("det")
    else
      Note("All plugins are up to date!")
    end

  else
    Note("No updates info available!")
  end

  G_tplug_keys = nil
  G_taux_keys = nil

  EnableAliasGroup("plugins_updater", true)
end


function find_plugin_data(id)
  local local_path = fix_slashes(GetPluginInfo(id, 20))
  local local_path_n_file = fix_slashes(GetPluginInfo(id, 6))

  local esc_lpath = string.gsub(local_path, "%p", "%%%1")
  local file_name = string.gsub(local_path_n_file, esc_lpath, "")

  local url_path
  local res, splug = CallPlugin(id, "plugin_update_url")
  if (res == 0) then -- supported
    url_path = string.gsub(fix_url(splug), file_name, "")
  end

  return url_path, local_path, file_name
end


function build_updated_aux_files_list(id, p_url_path, p_local_path)
  local taux = {}
  local aux_changed = false

  if (G_tlatest) and (G_tlatest[id]) then
    if (G_tlatest[id].taux) then
      taux, aux_changed = build_aux_from_detected(id, p_url_path, p_local_path)
    else
      taux, aux_changed = get_local_aux_data(id, p_url_path, p_local_path)
    end
  end

  return taux, aux_changed
end


function build_aux_from_detected(id, p_url_path, p_local_path)
  local taux = {}
  local aux_changed = false

  -- get paths for aux files
  local t_loc_aux_paths = get_local_aux_data(id, p_url_path, p_local_path)

  for i = 1, #G_tlatest[id].taux do
    if (not G_taux_keys[name]) then
    -- if it isn't added to updates already
      local name = G_tlatest[id].taux[i].name
      local lpath = fix_aux_path(G_tlatest[id].taux[i].dest, p_local_path)

      if (lpath) then
        local hash = get_file_hash(lpath .. name)

        if (G_tlatest[name]) and (G_tlatest[name] ~= hash) then
        -- if hash doesn't match
          aux_changed = true

          local url
          if (t_loc_aux_paths[name]) then
            url = t_loc_aux_paths[name].url or p_url_path
          else
            url = p_url_path
          end

          taux[name] = {
            url = url,
            lpath = lpath,
            update = true,
          }
        end

      else
        Note("> Can't find local path for file " .. name .. " (plugin " .. id .. ")")
      end
    end
  end

  return taux, aux_changed
end


function get_local_aux_data(id, p_url_path, p_local_path)
  local taux = {}
  local aux_changed = false

  local res, saux = CallPlugin(id, "plugin_update_aux_url")
  if (res == 0) then
  -- the local plugin knows it has aux files, getting their URLs from it

    for line in string.gmatch(saux, "[^;]+") do
      aux_changed = true

      local tpath = utils.split(line, ",")

      local aurl = fix_slashes(fix_url(tpath[1]))

      local t = utils.split(aurl, "/")
      local aux_file_name = t[#t]

      local esc_name = string.gsub(aux_file_name, "%p", "%%%1")
      local aux_url_path = string.gsub(aurl, aux_file_name, "")

      taux[aux_file_name] = {
        lpath = fix_local_path(tpath[2]) or p_local_path,
        url = fix_url(aux_url_path),
        update = true,
      }
    end
  end

  return taux, aux_changed
end


function fix_url(url)
  url = string.gsub(url, "dl.dropbox.com/u/65599194/mm%-updater/", "raw.githubusercontent.com/MateriaMagicaLLC/mm%-mushclient%-scripts/master/src/")
  url = string.gsub(url, "raw.githubusercontent.com/mu3r73/mm%-mushclient%-scripts/master/src/", "raw.githubusercontent.com/MateriaMagicaLLC/mm%-mushclient%-scripts/master/src/")
  return url
end


function fix_local_path(path)
  if (path) and (string.find(path, "^MUSH/") == 1) then
    path = string.gsub(path, "^MUSH/", GetInfo(56), 1)
    path = fix_slashes(path) .. "/"
  end

  return path
end


function fix_slashes(s)
  s = string.gsub(s, "\\", "/")
  return s
end


function fix_aux_path(auxdest, pluginlpath)
  if (auxdest) then
    auxdest = fix_local_path(Trim(auxdest))
  else
    auxdest = pluginlpath
  end

  return auxdest
end


function get_file_hash(filename)
  local f, s

  f = io.open(filename, "rb")
  if (f) then
    s = f:read("*all")
    f:close()
  end

  local hash
  if (s) then
    hash = utils.tohex(utils.md5(s))
  end

  return hash
end


function make_file_update_t(id, name, url_path, local_path, update)
  local tres = {
    id = id,
    name = name,
    url = url_path,
    lpath = local_path,
    update = update,
  }

  return tres
end



-------------------------
-- detect updates timer
-------------------------

function detect_updates_if_idling()
-- a timer calls this every 3 hours
  local idling_minutes = 5

  if (os.time() > (last_command + (idling_minutes * 60)))
  and (at_idling_location()) then
    -- I'm idling
    detect_updates()
  end
end


function OnPluginBroadcast(msg, id, name, text)
  if (id =="f67c4339ed0591a5b010d05b") then -- GMCP message
    if (text == "room.info") then -- room.info
      get_gmcp_room()
    end
  end
end


function get_gmcp_room()
  local res, gmcparg = CallPlugin("f67c4339ed0591a5b010d05b", "gmcpval", "room.info")
  luastmt = "gmcpdata = " .. gmcparg

  assert(loadstring(luastmt or ""))()
end


function at_idling_location()
  local res = false

  if (gmcpdata) then
    local zone = gmcpval("zone")

    if (zone) then
      if (string.match(zone, "^Chat Rooms"))
      or (string.match(zone, "Clan Hall$") and (not string.match(zone, "^Old")))
      or (string.match(zone, "^Player Homes ")) then
        res = true
      end
    end

  else
    res = true
  end

  return res
end



---------------
-- list stuff
---------------

function list_plugins(partial)
  G_tfiles = {}
  G_tplug_keys = {}
  G_taux_keys = {}

  Note("-- plugins_updater_v2: building the list of plugins matching '" .. partial .. "' --")

  local id, p_url_path, p_local_path, p_file_name

  for _, id in pairs(GetPluginList()) do
    local name = GetPluginInfo(id, 1)

    if (string.find(string.lower(name), string.lower(partial))) then
      p_url_path, p_local_path, p_file_name = find_plugin_data(id)

      if (p_url_path) then
        taux, _ = build_updated_aux_files_list(id, p_url_path, p_local_path)

        for name, tinfo in pairs(taux) do
          G_tfiles[#G_tfiles + 1] = make_file_update_t(nil, name, tinfo.url, tinfo.lpath, tinfo.update)
          G_taux_keys[name] = true
        end

        G_tfiles[#G_tfiles + 1] = make_file_update_t(id, p_file_name, p_url_path, p_local_path, true)
        G_tplug_keys[id] = true
      end
    end
  end

  if (#G_tfiles > 0) then
    do_list_plugins("partial")
  else
    Note("No supported plugins match that partial name!")
  end

  G_tplug_keys = nil
  G_taux_keys = nil
end


function do_list_plugins(mode)
  local tplugins = sort_plugins(G_tplug_keys)

  Note("")
  if (mode == "det") then
    Note("The following plugins have pending updates:")
  elseif (mode == "partial") then
    Note("Plugins matching your partial descriptions:")
  end

  local taux, name, id
  for i = 1, #tplugins do
    taux = utils.split(tplugins[i], ";")
    id = taux[2]
    name = taux[3]

    Tell("* " .. name .. " - ")
    Hyperlink("update plugin " .. id, "update plugin " .. id, "", "silver", "black", false)
    Note("")
  end

  Note("")
  Tell("Use: ")
  Hyperlink("update plugins lastlist", "update plugins lastlist", "", "silver", "black", false)
  Note(" to update all the plugins in the list above, and their aux files.")
  Note("")

  BroadcastPlugin(1, "|z044There are pending updates for some client scripts. Type '|Wupdate plugins lastlist|z044' (without the quotation marks) to install all the updates.")
  SetClipboard("update plugins lastlist")
end


function sort_plugins(t_plug_keys)
  local taux = {}

  local name, author

  for id, _ in pairs(t_plug_keys) do
    name = GetPluginInfo(id, 1)
    author = GetPluginInfo(id, 2)
    taux[#taux + 1] = string.lower(name) .. ";" .. id .. ";" .. name .. " (by " .. author .. ")"
  end
  table.sort(taux)

  return taux
end


function update_plugins_lastlist()
  if (G_tfiles) then
    Note("Downloading files...")
    EnableTimer("get_files_timer", true)

  else
    Note("-- plugins_updater_v2 - nothing to do! use 'update plugins', or 'update plugin <partial_name>' first, and then retry --")
  end
end



-----------------
-- update stuff
-----------------

function update_plugin(id)
  if (IsPluginInstalled(id)) then
    update_files(Trim(id))
  else
    list_plugins(id)
  end
end


function update_files(id)
  Note("-- plugins_updater_v2: downloading files --")

  Note("Building list of files to download...")
  build_download_list(id)

  if (#G_tfiles > 0) then
    Note("Downloading files...")
    EnableTimer("get_files_timer", true)

  else
    Note("Plugin not supported!")
  end
end


function build_download_list(id)
  G_tfiles = {}
  G_taux_keys = {}

  local p_url_path, p_local_path, p_file_name

  p_url_path, p_local_path, p_file_name = find_plugin_data(id)

  if (p_url_path) then
    taux, _ = build_updated_aux_files_list(id, p_url_path, p_local_path)

    for name, tinfo in pairs(taux) do
      G_tfiles[#G_tfiles + 1] = make_file_update_t(nil, name, tinfo.url, tinfo.lpath, tinfo.update)
      G_taux_keys[name] = true
    end

    G_tfiles[#G_tfiles + 1] = make_file_update_t(id, p_file_name, p_url_path, p_local_path, true)
  end

  G_taux_keys = nil
end



--------------------
-- get files timer
--------------------

function check_if_ready_to_get_file()
-- this requires the list of files to download in a global table, G_tfiles
  if (G_tfiles) then
--    Note(serialize.save_simple(tfiles))
    EnableAliasGroup("plugins_updater", false)

    if (#G_tfiles > 0) then

      if (not G_busy_downloading) then
      -- G_busy_downloading is a global var,
      -- used to sequence the list of downloads

        local a_file = table.remove(G_tfiles, 1)

        G_busy_downloading = true

        -- parameters for get_file
        local func_success, func_fail
        if (a_file.id) then -- it's a plugin
          if (a_file.update) then
            func_success = do_save_and_reinstall
          end
        else
          func_success = do_save_file
        end
        func_fail = do_if_fail

        local tparams = {
          id = a_file.id,
          lpath = a_file.lpath,
          filename = a_file.name,
        }

        if (func_success) then
          get_file(a_file.url .. a_file.name, func_success, func_fail, tparams)
        else
          do_reinstall(a_file.id)
        end
      end

    else
      G_tfiles = nil
    end

  elseif (not G_busy_downloading) then
    Note("... Done!")
    EnableTimer("get_files_timer", false)
    EnableAliasGroup("plugins_updater", true)
  end
end


function do_save_and_reinstall(file, tparams)
-- this will be called by get_file, once it's done downloading,
-- if the download was successful
  local res = save_file(tparams.lpath, tparams.filename, file)

  if (res == 0) then
    do_reinstall(tparams.id)
  end

  G_busy_downloading = false
end


function do_save_file(file, tparams)
-- this will be called by get_file, via do_get_file, once it's done downloading,
-- if the download was successful
  save_file(tparams.lpath, tparams.filename, file)

  G_busy_downloading = false
end


function do_reinstall(id)
  res = ReloadPlugin(id)

  if (res == 0) then
    Note("Plugin " .. id .. " (" .. GetPluginInfo(id, 1) .. ") updated successfully!")

  else
    Note("> error: I couldn't reload the plugin " .. id .. " (" .. GetPluginInfo(id, 1) .. "): " .. ErrorDesc(res) .. " - code: " .. res)

    if (res == 30046) then
      Tell("(... please try to reload the plugin manually: ")
      ColourTell("silver", "black", "Ctrl+Shift+P")
      Tell(", click ")
      ColourTell("silver", "black", GetPluginInfo(id, 1))
      Tell(", click ")
      ColourTell("silver", "black", "ReInstall")
      Note(")")
    end
  end

  G_busy_downloading = false
end


function do_if_fail()
-- this will be called by get_file, via do_get_file, once it's done downloading,
-- if the download failed
  G_busy_downloading = false
end



-------------------
-- https file get
-------------------

require "wait"

function get_file(url, func_success, func_fail, tparams)
  wait.make(function()
    local res, file, status, headers, full_status

    if (async_ok) and (not thread) then
      thread = async.request(url, "HTTPS")

      Note("")
      Note("- downloading: " .. url .. "...")
      SetStatus("Downloading file: " .. url .. "...")

      if (async_ok) then
        repeat
          wait.time(.5)
        until (thread:alive())

        res, file, status, headers, full_status = thread:join()

        thread = nil

        if (status == 200) then
          func_success(file, tparams)

        else -- http access error
          Note("> error accessing " .. url .. " - status: " .. status)
          func_fail(tparams)
        end
      end

      SetStatus("Ready")

    else
      Note("-- plugins_updater_v2 - error: couldn't load the network components --")
    end
  end)
end



----------------------
-- save file to disk
----------------------

function save_file(lpath, filename, file)
  -- create the directory if it doesn't exist
  local ok, msg
  ok = mkdir_if_needed(lpath)

  if (ok) then
    -- rename the old version of the file, 2 backups are kept
    ok, msg = os.remove(lpath .. filename .. ".older")
    ok, msg = os.rename(lpath .. filename .. ".old", lpath .. filename .. ".older")
    ok, msg = os.rename(lpath .. filename, lpath .. filename .. ".old")
--    if (not ok) then
--      Note("> warning: I couldn't rename the file " .. msg)
--    end

    local f, res, rescode

    -- (re)create the file
    f, res, rescode = io.open(lpath .. filename, "wb")
    if (f == nil) then
      Note("> error creating the file: " .. res .. " - code: " .. rescode .. " - restoring the original file.")
      ok, msg = os.rename(lpath .. filename .. ".old", lpath .. filename) -- restore original file
      if (not ok) then
        Note("> warning: I couldn't rename the file " .. msg)
      end
      return -1
    end

    -- save the contents
    f:write(file)
    f:flush()
    f:close()

    return 0

  else
    Note("> error: the directory " .. lpath .. " doesn't exist, and I couldn't create it.")
    return -1
  end
end


function mkdir_if_needed(lpath)
  local t, e, ok

  t, e = utils.readdir(lpath)

  if (not t) then
    t = utils.split(lpath, "/")
    local dirname = t[#t]

    lpath = string.gsub(lpath, dirname, "")

    ok, e = utils.shellexecute("cmd", "/C mkdir " .. dirname, lpath, "open", 0)

  else
    ok = true
  end

  return ok
end


]]>

</script>

</muclient>
