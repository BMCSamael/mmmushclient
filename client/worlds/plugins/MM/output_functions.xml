<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, April 06, 2010, 8:39 AM -->
<!-- MuClient version 4.46 -->

<!-- Plugin "output_functions" generated by Plugin Wizard -->

<muclient>

<plugin
   name="output_functions"
   author="Oriol Gomez, Ruthgul"
   id="54846c23d8b15594e7eb4b8a"
   save_state="y"
   language="Lua"
   purpose="provides functions to help tts users."
   date_written="2010-04-06 08:37:40"
   date_modified="2014-11-06 11:48:43"
   requires="4.46"
   version="1.0"
   >

<description trim="y">
<![CDATA[

~ output_functions ~

Keystrokes:
Ctrl + <number>  =  Line_Get <number>, where <number> is 1 to 9, or 0

Aliases:
clearoutput
toggleoutput
toggleinterrupt
search world <what>
prevline
curline
nextline
topline
endline
select
snap_shot
Line_Get <number>

Authors: Oriol Gomez, Ruthgul

Changes added by Ruthgul:
- added this help screen
- removed most keystrokes, leaving only Ctrl + 0 .. 9
- made it use accelerators to add the keystrokes, if that plugin is present
- added the search world alias
- made it compatible with plugins_updater
- made LineGet ignore blank lines
- made it not append blank lines to the output notepad
- make the output notepad not nag "wanna save me?" when it is closed
- made it auto-clear the notepad once it reaches (1/2)+ capacity, if idling
- made it read the results of searc world, if MushReader is detected

]]>
</description>

</plugin>


<!--  Aliases  -->

<aliases>

  <alias
   match="^search world (.+)$"
   enabled="y"
   group="world_window"
   omit_from_log="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>search_world("%1")
</send>
  </alias>

  <alias
    match="Line_Get *"
    enabled="y"
    script="LineGet"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="clearoutput"
    enabled="y"
    script="clearlines"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="prevline"
    enabled="y"
    script="prev_line"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="toggleoutput"
    enabled="y"
    script="output_toggle"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="toggleinterrupt"
    enabled="y"
    script="interrupt_toggle"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="curline"
    enabled="y"
    script="cur_line"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="select"
    enabled="y"
    script="selectscr"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="nextline"
    enabled="y"
    script="next_line"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="topline"
    enabled="y"
    script="top_line"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="snap_shot"
    enabled="y"
    script="snapshot"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
    match="endline"
    enabled="y"
    script="end_line"
    omit_from_output="y"
    omit_from_log="y"
    omit_from_command_history="y"
    send_to="12"
    sequence="100">
  <send>
</send>
  </alias>

  <alias
   enabled="y"
   match="^output\_functions(|( |\:)help)$"
   regexp="y"
   ignore_case="y"
   omit_from_log="y"
   omit_from_output="y"
   script="OnHelp"
   sequence="100"
  >
  </alias>

</aliases>



<!--  Get our standard constants -->

<include name="constants.lua"/>



<!--  Script  -->

<script>

<![CDATA[

modes = {} -- for keyboard states
msgbuffer = {}
cline = 1
lastcount = 0
line = 0
mode = {}
idling = false

require "wait"
require "gmcphelper"


function OnPluginInstall()
  wait.make(function()
    Note(GetPluginInfo(GetPluginID(), 1) .. ": type " .. GetPluginInfo(GetPluginID(), 1) .. " help to see info about this plugin")

    if (GetVariable("output") == nil) then
      SetVariable("output","1")
    end

    -- keystrokes
    if (is_accelerators_present()) then
      for i = 1, 9 do
        add_accelerator("ctrl + " .. tostring(i), "Line_Get " .. tostring(i), "no")
      end
      add_accelerator("ctrl + 0", "Line_Get 10", "no")

    else
      for i = 1, 9 do
        Accelerator("ctrl + " .. tostring(i), "Line_Get " .. tostring(i))
      end
      Accelerator("ctrl + 0", "Line_Get 10")
    end

    -- give the plugins some time to initialize
    wait.time(3)
    detect_reader()
  end)

  --Accelerator("ctrl + shift + c", "clearoutput")
  --Accelerator("ctrl + shift + o","nextline")
  --Accelerator("ctrl + alt + enter","toggleinterrupt")
  --Accelerator("ctrl + alt + o","toggleoutput")
  --Accelerator("ctrl + shift + i","curline")
  --Accelerator("ctrl + shift + space","select")
  --Accelerator("ctrl + shift + u","prevline")
  --Accelerator("ctrl + shift + n","endline")
  --Accelerator("ctrl + shift + y","topline")
  --Accelerator("ctrl + shift + s","snap_shot")
end


function OnPluginCommandEntered(s)
  if world.GetVariable("interrupt") == "1" then
    Execute("tts_stop")
  end
end


function OnPluginScreendraw(t, l, line)
  --Execute("tts_note " .. tostring(GetLinesInBufferCount()))
  curcount = GetLinesInBufferCount()
  if curcount < (lastcount or 0) then
    cline = cline - 100
  end
  lastcount = curcount
  if (GetVariable("output") == "0") then
    return
  end
  if (Trim(line) == "") then
    return
  end
  if (GetInfo(113) == false) then
    table.insert(msgbuffer, line)
  else
    add_to_notepad("output", line)
  end
end


function add_to_notepad(notepad, txt)
  if (GetNotepadLength(notepad) > 524288) and (idling) then
  -- notepad is (1/2)+ full and we're idling in Social
    ReplaceNotepad(notepad, txt .. "\r\n")
  else
    AppendToNotepad(notepad, txt .. "\r\n")
  end

  -- make the notepad not nag "wanna save me?" when it is closed
  NotepadSaveMethod(notepad, 2)
end


function OnPluginGetFocus()
  if (GetVariable("output") == "0") then
    return
  end
  if (#msgbuffer > 0) then
    for i, buffered in ipairs(msgbuffer) do
      AppendToNotepad("output", buffered .. "\r\n")
    end
    msgbuffer = {}
  end
end


function OnPluginListChanged()
  detect_reader()
end


function detect_reader()
  reader_present = reader_plugin_present()
end


function is_plugin_present(name, id)
  local res = false

  local plugin_name = GetPluginInfo(id, 1)

  if (plugin_name == name) then
    -- is it enabled?
    if (GetPluginInfo(id, 17)) then
      res = true
    end
  end

  return res
end


function OnHelp()
  world.Note(world.GetPluginInfo(world.GetPluginID(), 3))
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/output_functions.xml",
  }
  return (table.concat(t, ";"))
end



-- aliases

function selectscr()
  if (selecting == 0) or (selecting == nil) then
    selecting = 1
    Execute("tts_interrupt selection start.")
    tselect = {}
    sline = cline
  else
    Execute("tts_interrupt Selection copied.")
    for i = sline, cline do
      table.insert(tselect,GetLineInfo(i,1))
    end
    SetClipboard(table.concat(tselect, "\n"))
    selecting = 0
    tselect = {}
  end
end


function output_toggle()
  if (GetVariable("output") == "0") or (GetVariable("output") == nil) then
    SetVariable("output", "1")
    Note("output notepad on")
  else
    Note("output notepad off")
    SetVariable("output", "0")
  end
end


function interrupt_toggle()
  if (GetVariable("interrupt") == "1") or (GetVariable("interrupt") == nil) then
    SetVariable("interrupt", "0")
    Note("interrupt on enter off")
  else
    Note("interrupt on enter on")
    SetVariable("interrupt", "1")
  end
end


function LineGet(name, line, wc)
  lines = GetLinesInBufferCount()
  line = nil

--  line = GetLineInfo(lines - wc[1], 1)

  local output_line_num = lines
  local count = 0

  while (count < tonumber(wc[1])) and (output_line_num > 0) do
    output_line_num = output_line_num - 1

    if (Trim(GetLineInfo(output_line_num, 1)) ~= "") then
      count = count + 1
    end

    if (count == tonumber(wc[1])) then
      line = GetLineInfo(output_line_num, 1)
    end
  end

  wc = wc[1]
  local timeout = 0.4 -- in seconds
  if modes[wc] == nil then
    modes[wc] = {os.clock(), 1}
  elseif os.clock() - modes[wc][1] >= timeout then
    modes[wc][1] = os.clock()
    modes[wc][2] = 1
  else
    modes[wc][1] = os.clock()
    modes[wc][2] = modes[wc][2] + 1
  end
  if modes[wc][2] > 3 then
    modes[wc][2] = 3
  end
  if modes[wc][2] == 3 then
    if (line) then
      PasteCommand(line)
      Execute("tts_interrupt pasted.")
    end
  end
  if modes[wc][2] == 2 then
    if (line) then
      SetClipboard(line)
      Execute("tts_interrupt copied.")
    end
  end
  if modes[wc][2] == 1 then
    if (line) then
      Execute("tts_interrupt " .. line)
    end
  end
end


function prev_line()
  lines = GetLinesInBufferCount()
  if (cline <= 1) then
    top_line()
  else
    cline = cline - 1
    while (GetLineInfo(cline, 1) == "") and not (cline <= 1) and not (cline >= GetLinesInBufferCount()) do
      cline = cline - 1
    end
    line = GetLineInfo(cline, 1)
    if (line == "") then
      cline = cline + 1
      line = GetLineInfo(cline, 1)
    end
    Execute("tts_interrupt " .. line)
  end
end


function cur_line()
  if(cline < 1) then
    cline = 1
  end
  while (GetLineInfo(cline, 1) == "") and not (cline <= 1) and not (cline >= GetLinesInBufferCount()) do
    cline = cline + 1
  end
  line = GetLineInfo(cline, 1)
  if (line == "") then
    cline = cline + 1
    line = GetLineInfo(cline, 1)
  end
  Execute("tts_interrupt " .. line)
end


function next_line()
  lines = GetLinesInBufferCount()
  if (cline < 1) then
    cline = 1
  end
  if (cline >= lines) then
    Execute("tts_interrupt bottom")
  else
    cline = cline + 1
    while (GetLineInfo(cline, 1) == "") and not (cline <= 1) and not (cline >= GetLinesInBufferCount()) do
      cline = cline + 1
    end
    line = GetLineInfo(cline, 1)
    if (line == "") then
      cline = cline - 1
      line = GetLineInfo(cline, 1)
    end
    Execute("tts_interrupt " .. line)
  end
end


function end_line()
  cline = GetLinesInBufferCount()
  while (GetLineInfo(cline, 1) == "") and not (cline <= 1) and not (cline > GetLinesInBufferCount()) do
    cline = cline - 1
  end
  line = GetLineInfo(cline, 1)
  if (line == "") then
    cline = cline + 1
    line = GetLineInfo(cline, 1)
  end
  Execute("tts_interrupt Bottom: " .. line)
end


function top_line()
  cline = 1
  while (GetLineInfo(cline, 1) == "") and not (cline < 1) and not (cline >= GetLinesInBufferCount()) do
    cline = cline + 1
  end
  line = GetLineInfo(cline, 1)
  if (line == "") then
    cline = cline - 1
    line = GetLineInfo(cline, 1)
  end
  Execute("tts_interrupt top: " .. line)
end


function snapshot()
  for snapline = 1, GetLinesInBufferCount() do
    AppendToNotepad("snapshot", GetLineInfo(snapline, 1) .. "\r\n")
    ActivateNotepad("snapshot ")
  end
end


function clearlines(n, l, w)
  world.DeleteOutput()
  world.Note("output cleared")
  cline = 1
  lastcount = 0
  line = GetLineInfo(cline, 1)
end


function search_world(what)
  local t = {}
  local txt
  what = string.lower(Trim(what))

  for i = 1, GetLinesInBufferCount() do
    txt = GetLineInfo(i, 1)
    if (string.find(string.lower(txt), what)) then
      t[#t + 1] = txt
    end
  end

  for i = #t, 1, -1 do
    read_text(t[i])
  end
end



-- interface with accelerators

function is_accelerators_present()
  local plugin_name = GetPluginInfo("f99134f19ea994a0cc0888d1", 1)

  local res = false

  if (plugin_name == "accelerators") then
    if (GetPluginInfo("f99134f19ea994a0cc0888d1", 17)) then
      res = true
    end
  end

  return res
end


function add_accelerator(keystroke, command, override)
  local res, val

  res, val = CallPlugin("f99134f19ea994a0cc0888d1", "add_accelerator", keystroke, command, override)

  if (res ~= 0) then
    val = false
  end

  return val
end



-- interface with GMCP

function OnPluginBroadcast(msg, id, name, text)
  if (id == "f67c4339ed0591a5b010d05b") -- GMCP handler
  and (name == "MM_GMCP_handler")
  and (text == "room.info") then
    get_gmcp_room()
    idling = at_idling_location()
  end
end


function get_gmcp_room()
  local res, gmcparg = CallPlugin("f67c4339ed0591a5b010d05b", "gmcpval", "room.info")
  luastmt = "gmcpdata = " .. gmcparg

  assert(loadstring(luastmt or ""))()
end


function at_idling_location()
  local res = false

  local zone = gmcpval("zone")

  if (string.match(zone, "^Chat Rooms")) then
    res = true
  end

  return res
end



-- interface with MushReader

function read_text(txt)
  local res

  if (reader_present) then
    res = CallPlugin("925cdd0331023d9f0b8f05a7", "say", txt)
  else
    Note(txt)
  end

--  Note(res)
end


function reader_plugin_present()
  return is_plugin_present("MushReader", "925cdd0331023d9f0b8f05a7")
end


]]>

</script>

</muclient>
