<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Wednesday, September 26, 2012, 10:16 AM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "mobs_n_items" generated by Plugin Wizard -->

<muclient>

<plugin
  name="mobs_n_items"
  author="Ruthgul"
  id="8755063a5cf00f3312b113e6"
  language="Lua"
  purpose="NPCs and items database"
  save_state="y"
  date_written="2012-09-26 10:15:07"
  date_modified="2020-10-01 05:26:36"
  requires="4.71"
  version="1.0"
>

<description trim="y">

<![CDATA[

.----------------.
 | mobs_n_items |
`----------------'

Implements a database for NPCs and items.


** REQUIRES **

- Game settings: MXP must be ON, to auto-detect NPCs & items [ Client setting: Game, Configure, MXP / Pueblo... > Use MXP / Pueblo: On command (or Yes - always). ]
- MM GMCP Handler, to auto-detect room & area for items
- MM_GMCP_Mapper, to search for and speedwalk to rooms
- Speedwalk_Manager_GMCP_P2, to search for and speedwalk to areas


Syntax:

> queries:

* mob where <mob_name> [a:<area_name>]  - fuzzy search by mob name
* item where <item_name> [a:<area_name>]  - fuzzy search by item name
* skill where <skill_name> [a:<area_name>]  - search by exact skill name

* mob wheree <mob_name> [a:<area_name>]  - search by exact mob name
* item wheree <item_name> [a:<area_name>]  - search by exact item name
* skill wheree <skill_name> [a:<area_name>]  - search by exact skill name

> additions:

* add mxp [on|off]  - toggle auto-add mobs and items via MXP (BETA, OFF by default)
* add mxp 1stock [on|off]  - toggle auto-add 1-stock items (BETA, OFF by default)
* add mxp ground [on|off]  - toggle auto-add items on the ground (ON by default)

* add mob <mob_id> n:<name> [l:<long_desc>] - adds a new NPC to the database, <mob_id> must be unique
* add item <item_id> n:<name> [l:<long_desc>] - adds a new item to the database, <item_id> must be unique
* add skill <skill_id> n:<name> - adds a new skill to the database, <skill_id> must be unique

* add mob location <mob_id> [a:<area_name>] [r:<room_name_or_number>] - adds a new NPC location to the database
* add item location <item_id> [a:<area_name>] [m:<mob_id>] [r:<room_name_or_number>] - adds a new item location to the database
* add trainer <skill_id> <mob_id> - adds a new trainer for the skill

> deletions:

* delete mob <mob_id> - removes an NPC from the database
* delete item <item_id> - removes an item from the database
* delete skill <skill_id> - removes a skill from the database

* delete mob location <mob_id> [a:<area_name>] [r:<room_name_or_number>] - removes an NPC's location from the database
* delete item location <item_id> [a:<area_name>] [m:<mob_id>] [r:<room_name_or_number>] - removes an item's location from the database
* delete trainer <skill_id> <mob_id> - removes a trainer for the skill from the database


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Aliases  -->

<aliases>

<!-- toggles -->

  <alias
    enabled="y"
    match="^add[ ]+mxp(|[ ]+(?<status>on|off))$"
    regexp="y"
    sequence="100"
    script="toggle_add_mxp"
  >
  </alias>

  <alias
    enabled="y"
    match="^add[ ]+mxp[ ]+1stock(|[ ]+(?<status>on|off))$"
    regexp="y"
    sequence="100"
    script="toggle_add_mxp_1stock"
  >
  </alias>

  <alias
    enabled="y"
    match="^add[ ]+mxp[ ]+ground(|[ ]+(?<status>on|off))$"
    regexp="y"
    sequence="100"
    script="toggle_add_mxp_ground"
  >
  </alias>


<!-- additions -->

  <alias
   enabled="y"
   match="^add mob (?<id>[^\:]+) n\:(?<name>[^\:]+)(| l\:(?<long>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="add_mob_c"
  >
  </alias>

  <alias
   enabled="y"
   match="^add item (?<id>[^\:]+) n\:(?<name>[^\:]+)(| l\:(?<long>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="add_item_c"
  >
  </alias>

  <alias
   enabled="y"
   match="^add skill (?<id>[^\:]+) n\:(?<name>[^\:]+)$"
   regexp="y"
   sequence="100"
   script="add_skill"
  >
  </alias>


<!-- ... locations -->

  <alias
   enabled="y"
   match="^add mob loc(|ation) (?<mobid>[^\:]+)(| a\:(?<area>[^\:]+))(| r\:(?<room>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="add_mob_location_c"
  >
  </alias>

  <alias
   enabled="y"
   match="^add item loc(|ation) (?<itemid>[^\:]+)(| a\:(?<area>[^\:]+))(| m\:(?<mobid>[^\:]+))(| r\:(?<room>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="add_item_location_c"
  >
  </alias>

  <alias
   enabled="y"
   match="^add trainer (?<skillid>[^\:]+) (?<mobid>[^\:]+)$"
   regexp="y"
   sequence="100"
   script="add_skill_trainer"
  >
  </alias>


<!-- deletions -->

  <alias
   enabled="y"
   match="^del(|ete) mob (?<id>[^\:]+)$"
   regexp="y"
   sequence="100"
   script="del_mob"
  >
  </alias>

  <alias
   enabled="y"
   match="^del(|ete) item (?<id>[^\:]+)$"
   regexp="y"
   sequence="100"
   script="del_item"
  >
  </alias>

  <alias
   enabled="y"
   match="^del(|ete) skill (?<id>[^\:]+)$"
   regexp="y"
   sequence="100"
   script="del_skill"
  >
  </alias>


<!-- ... locations -->

  <alias
   enabled="y"
   match="^del(|ete) mob loc(|ation) (?<mobid>[^\:]+)(| a\:(?<area>[^\:]+))(| r\:(?<room>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="del_mob_location"
  >
  </alias>

  <alias
   enabled="y"
   match="^del(|ete) item loc(|ation) (?<itemid>[^\:]+)(| a\:(?<area>[^\:]+))(| m\:(?<mobid>[^\:]+))(| r\:(?<room>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="del_item_location"
  >
  </alias>

  <alias
   enabled="y"
   match="^del(|ete) trainer (?<skillid>[^\:]+) (?<mobid>[^\:]+)$"
   regexp="y"
   sequence="100"
   script="del_skill_trainer"
  >
  </alias>


<!-- queries -->

  <alias
   enabled="y"
   match="^mob wheree (?<name>[^\:]+)(| a\:(?<area>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="find_npc_strict"
  >
  </alias>

  <alias
   enabled="y"
   match="^mob where (?<name>[^\:]+)(| a\:(?<area>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="find_npc_fuzzy"
  >
  </alias>

  <alias
   enabled="y"
   match="^item wheree (?<name>[^\:]+)(| a\:(?<area>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="find_item_strict"
  >
  </alias>

  <alias
   enabled="y"
   match="^item where (?<name>[^\:]+)(| a\:(?<area>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="find_item_fuzzy"
  >
  </alias>

  <alias
   enabled="y"
   match="^skill wheree (?<name>[^\:]+)(| a\:(?<area>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="find_skill_strict"
  >
  </alias>

  <alias
   enabled="y"
   match="^skill where (?<name>[^\:]+)(| a\:(?<area>[^\:]+))$"
   regexp="y"
   sequence="100"
   script="find_skill_fuzzy"
  >
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^mobs\_n\_items(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Triggers  -->

<triggers>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^[ ]*[0-9]+\) (.+) [0-9]+ [ ]* (?<amount>No limit|[0-9\,]+) [ ]+\[[ ]*[0-9\,]+ (|gp|gold)\]$"
   regexp="y"
   sequence="100"
   script="add_item_if_stock_c"
  >
  </trigger>

</triggers>



<!--  Scripts  -->

<script>

<![CDATA[

require "serialize"
require "gmcphelper"


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
  ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
  Note(" to see info about this plugin --")

  -- open databases on disk
  db = assert(sqlite3.open(GetInfo(66) .. "mm_mobs_n_items.db"))

  create_tables()    -- create database structure if necessary

  init_vars()
end


function OnPluginDisconnect()
  update_hits()
--  db:close()
end


function OnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID(), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo(GetPluginID(), 14)) .. ")")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/mobs_n_items.xml",
  }
  return (table.concat(t, ";"))
end



-----------------
-- config stuff
-----------------

function init_vars()
  gmcp_initialized = false

  load_config()

  mobs_locations_cache = {}
  items_locations_cache = {}
end


function load_config()
  config = {
    addMXP = ((GetVariable("addMXP") or "false") == "true"),
    addMXP1stock = ((GetVariable("addMXP1stock") or "false") == "true"),
    addMXPground = ((GetVariable("addMXPground") or "true") == "true"),
  }
end


function toggle_add_mxp(name, line, wildcards)
  local status = wildcards.status

  config.addMXP = do_toggle(config.addMXP, status)
  save_config()

  if (config.addMXP) then
    Note("-- mobs_n_items: will now auto-add mobs and items via MXP --")

  else
    Note("-- mobs_n_items: will no longer auto-add mobs and items via MXP --")

    -- clear caches
    mobs_locations_cache = {}
    items_locations_cache = {}
  end
end


function toggle_add_mxp_1stock(name, line, wildcards)
  local status = wildcards.status

  config.addMXP1stock = do_toggle(config.addMXP1stock, status)
  save_config()

  if (config.addMXP1stock) then
    Note("-- mobs_n_items: will now auto-add 1-stock shop items via MXP --")

  else
    Note("-- mobs_n_items: will no longer auto-add 1-stock shop items via MXP --")
  end
end


function toggle_add_mxp_ground(name, line, wildcards)
  local status = wildcards.status

  config.addMXPground = do_toggle(config.addMXPground, status)
  save_config()

  if (config.addMXPground) then
    Note("-- mobs_n_items: will now auto-add items on the ground via MXP --")

  else
    Note("-- mobs_n_items: will no longer auto-add items on the ground via MXP --")
  end
end


function do_toggle(var, status)
  if (status == "on") then
    var = true
  elseif (status == "off") then
    var = false
  else
    var = not var
  end

  return var
end


function save_config()
  SetVariable("addMXP", tostring(config.addMXP))
  SetVariable("addMXP1stock", tostring(config.addMXP1stock))
  SetVariable("addMXPground", tostring(config.addMXPground))

  SaveState()
end



------------------
-- general stuff
------------------

function uncapitalize(name)
  if (not name) then
    return
  end

  if (name == "") then
     return ""
  end

  local c = string.lower(string.sub(name, 1, 1))
  if (string.len(name) == 1) then
    return c
  end

  local res = c .. string.sub(name, 2, string.len(name))
  return res
end


function is_in_table(t, item)
  local res = false

  for i = 1, #t do
    if (string.upper(t[i]) == string.upper(item)) then
    -- not case sensitive
      res = true
      break
    end
  end

  return res
end



-------------------
-- database stuff
-------------------

function dbcheck(code)
 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg()   -- the rollback will change the error message
    db:exec("ROLLBACK")       -- rollback any transaction to unlock the database
    error(err, 2)             -- show error in caller's context
  end
end


function fixsql(s)
  if s then
    return "'" .. (string.gsub(s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end
end


function create_tables()
  -- create table
  dbcheck(db:execute[[
    PRAGMA foreign_keys = ON;
    PRAGMA journal_mode = WAL;

    CREATE TABLE IF NOT EXISTS mobs(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      mobid         TEXT,            -- NPC's unique id
      name          TEXT NOT NULL,   -- name of the NPC
      long_desc     TEXT,            -- name as it appears in the room
      date_added    DATE,
      UNIQUE(mobid)
    );

    CREATE TABLE IF NOT EXISTS mobsloc(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      mobid         TEXT NOT NULL,   -- NPC's unique id
      area          TEXT,            -- name of the area
      room          TEXT,            -- name of the room where it pops
      hits          INTEGER,         -- times the NPC has been seen in the room
      date_added    DATE
    );


    CREATE TABLE IF NOT EXISTS items(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      itemid        TEXT,            -- item's unique id
      name          TEXT NOT NULL,   -- name of the item
      long_desc     TEXT,            -- name as it appears on the ground
      date_added    DATE,
      UNIQUE(itemid)
    );

    CREATE TABLE IF NOT EXISTS itemsloc(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      itemid        TEXT NOT NULL,   -- item's unique id
      area          TEXT,            -- name of the area
      mobid         TEXT,            -- id of the NPC who carries it, if applicable
      room          TEXT,            -- name of the room, if applicable
      hits          INTEGER,         -- times the item has been seen in the room
      date_added    DATE
    );


    CREATE TABLE IF NOT EXISTS skills(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      skillid       TEXT,            -- skill/spell's unique id
      name          TEXT NOT NULL,   -- name of the skill or spell
      date_added    DATE,
      UNIQUE(skillid)
    );

    CREATE TABLE IF NOT EXISTS skillstrain(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      skillid       TEXT NOT NULL,   -- skill/spell's unique id
      mobid         TEXT,            -- id of the NPC who trains it
      date_added    DATE
    );
 ]])
end



---------
-- gmcp
---------

function OnPluginBroadcast(msg, id, name, text)
  if (id =="f67c4339ed0591a5b010d05b") then -- GMCP message
    if (text == "room.info") then -- room.info
      if (not gmcp_initialized) then
        gmcp_initialized = true
      end

      get_gmcp_room()

      if (config.addMXP) then
        process_room()
      end
    end
  end
end


function get_gmcp_room()
  local res, gmcparg = CallPlugin("f67c4339ed0591a5b010d05b", "gmcpval", "room.info")
  luastmt = "gmcpdata = " .. gmcparg

  assert(loadstring(luastmt or ""))()
end


function process_room()
  room = {}
  room.num = gmcpval("num")
  room.zone = gmcpval("zone")
  room.name = gmcpval("name")

  if (not oldzone) then -- first run
    oldzone = room.zone
    load_area_hits(room.zone)

  elseif (oldzone ~= room.zone) then -- area changed
    update_hits()
    oldzone = room.zone
    load_area_hits(room.zone)
  end
end



--------
-- MXP
--------

function OnPluginMXPopenTag(name, args, mylist)
--  print(name)
  if (config.addMXP) then
    if (not entity) then
      entity = {}
    end

    if (string.find(name, "get") == 1) then             -- item on the ground
      entity.short, _ = string.match(name, 'get, name="(.+)" desc="(.+)"')
      entity.type = "item"

    elseif (string.find(name, "shop") == 1) then        -- item sold in a shop
      _, entity.short = string.match(name, 'shop, name=(.+) desc="(.+)"')
      entity.type = "item"

    -- items in inventory are 'drop, ...'

    elseif (string.find(name, "pers") == 1) then        -- NPC or player
      entity.short, _ = string.match(name, 'pers, name="(.+)" desc="(.+)"')
      entity.type = "npc"

    else
--      AppendToNotepad("MXP", "Opening tag: " .. name .. "\r\n\r\n")
    end
  end
end


function OnPluginMXPcloseTag(name, text)
  local ground = false
  local shop = false

  if (not entity) then
    entity = {}
  end

  if (config.addMXP) then
    if (string.find(name, "get") == 1) then             -- item on the ground
      ground = true
      entity.long = string.match(name, "get,(.+)")

    elseif (string.find(name, "shop") == 1) then        -- iten sold in a shop
      shop = true
      entity.long = string.match(name, "shop,(.+)")

    elseif (string.find(name, "pers") == 1) then        -- NPC or player
      entity.long = string.match(name, "pers,(.+)")

    else
--      AppendToNotepad("mxp", "Closing tag: " .. name .. "\r\n\r\n")
    end

    if (entity.short) and (entity.long) then
      if (entity.type == "npc") then
        add_npc_if_new()

      elseif (entity.type == "item") then
        if (not shop) -- shop items are added by add_item_if_stock()
        and ((not ground) or (config.addMXPground)) then -- add items on the ground?
          add_item_if_new()
        end
      end
    end
  end
end


function add_npc_if_new()
  if (gmcp_initialized) and (room) and (entity) then
    if (not is_player(entity.short, entity.long))
    and (not is_player_built_area(room.zone)) then
      local hash = Hash(string.lower(entity.short) .. entity.long .. room.zone)

      if (mobs_locations_cache[hash]) then
        if (mobs_locations_cache[hash][room.zone .. '|' .. room.name]) then
          mobs_locations_cache[hash][room.zone .. '|' .. room.name].hits = mobs_locations_cache[hash][room.zone .. '|' .. room.name].hits + 1
          mobs_locations_cache[hash][room.zone .. '|' .. room.name].changed = true

        else
          add_mob_location(hash, room.zone, room.name, true)
          mobs_locations_cache[hash][room.zone .. '|' .. room.name] = {
            hits = 1,
            changed = true,
          }
        end

      else
        add_mob(hash, entity.short, entity.long, true)
        add_mob_location(hash, room.zone, room.name, true)
        mobs_locations_cache[hash] = {}
        mobs_locations_cache[hash][room.zone .. '|' .. room.name] = {
          hits = 1,
          changed = true,
        }
      end
    end

    entity = nil
  end
end


function add_item_if_stock_c(name, line, wildcards)
  local amount = wildcards.amount
  add_item_if_stock(amount)
end


function add_item_if_stock(amount)
-- shop items are checked vs stock, to avoid ading items sold by players
  if (config.addMXP) then
--    print(amount)

    local num = string.gsub(amount, ",", "")
    num = tonumber(num)

    if (amount == "No limit")
    or (config.addMXP1stock)
    or ((num) and (num > 1)) then
--      print("add_item_if_stock()")
      add_item_if_new()

    elseif (num == 1) then
      entity = nil
    end
  end
end


function add_item_if_new()
  if (gmcp_initialized) and (room) and (entity) then
    if (not is_player_built_area(room.zone))
    and (not is_donation(room.num)) then
      local hash = Hash(entity.short .. entity.long .. room.zone)

      if (items_locations_cache[hash]) then
        if (items_locations_cache[hash][room.zone .. '|' .. room.name]) then
          items_locations_cache[hash][room.zone .. '|' .. room.name].hits = items_locations_cache[hash][room.zone .. '|' .. room.name].hits + 1
          items_locations_cache[hash][room.zone .. '|' .. room.name].changed = true

        else
          add_item_location(hash, room.zone, "", room.name, true)
          items_locations_cache[hash][room.zone .. '|' .. room.name] = {
            hits = 1,
            changed = true,
          }
        end

      else
        add_item(hash, entity.short, entity.long, true)
        add_item_location(hash, room.zone, "", room.name, true)
        items_locations_cache[hash] = {}
        items_locations_cache[hash][room.zone .. '|' .. room.name] = {
          hits = 1,
          changed = true,
        }
      end
    end

    entity = nil
  end
end


function is_player(short, long)
  local res = false

  local t = utils.split(short, " ")
  if (#t == 1) and (short == long) then -- it's a player
    res = true
  end

  return res
end


function is_player_built_area(zone)
  local res = false

  if (string.find(zone, "Clan Hall"))
  or (string.find(zone, "Player Homes")) then
    res = true
  end

  return res
end


function is_donation(uid)
  local donation_rooms = {
    ["10440"] = "x", -- Rune
    ["11424"] = "x", -- Lasler
    ["28079"] = "x", -- Sigil
    ["41663"] = "x", -- Tellerium
    ["61078"] = "x", -- Irda
    ["63054"] = "x", -- New Rigel
    ["68037"] = "x", -- Maldra Keep
    ["73977"] = "x", -- Xaventry
    ["946210"] = "x", -- Rune Forest
  }

  return (donation_rooms[uid] == "x")
end



-----------------------
-- read from database
-----------------------

function load_mob_from_database(id)
  local mob, loc

  for row in db:nrows(string.format("SELECT * FROM mobs WHERE mobid = %s", fixsql(id))) do
    mob = {
      mobid = row.mobid,
      name = row.name,
      long_desc = row.long_desc,
      roomnums = {},
      locations = {},
    }
  end

  for row in db:nrows(string.format("SELECT * FROM mobsloc WHERE mobid = %s", fixsql(id))) do
    if (tonumber(row.room)) then -- room is a number? => it's a GMCP number
      mob.roomnums[#mob.roomnums + 1] = tonumber(row.room)

    else -- otherwise, it's a room (+ area) name
      loc = {
        area = row.area,
        room = row.room,
        hits = row.hits or 0,
      }

      mob.locations = insert_sorted(mob.locations, loc)
    end
  end

  if (mob) and (config.addMXP) then
    add_mob_to_locations_cache(mob)
  end

  return mob
end


function load_item_from_database(id)
  local item

  for row in db:nrows(string.format("SELECT * FROM items WHERE itemid = %s", fixsql(id))) do
    item = {
      itemid = row.itemid,
      name = row.name,
      long_desc = row.long_desc,
      locations = {},
    }
  end

  for row in db:nrows(string.format("SELECT * FROM itemsloc WHERE itemid = %s", fixsql(id))) do
    loc = {
      area = row.area,
      mobid = row.mobid,
      room = row.room,
      hits = row.hits or 0,
    }

    item.locations = insert_sorted(item.locations, loc)
  end

  if (item) and (config.addMXP) then
    add_item_to_locations_cache(item)
  end

  return item
end


function insert_sorted(locations, aloc)
-- inserts aloc in the locations table, sorted by hits (reverse order)
  local inserted = false

  for i = 1, #locations do
    if (aloc.hits > locations[i].hits) then
      table.insert(locations, i, aloc)
      inserted = true
      break
    end
  end

  if (not inserted) then -- append it
    table.insert(locations, aloc)
  end

  return locations
end


function load_skill_from_database(id)
  local skill

  for row in db:nrows(string.format("SELECT * FROM skills WHERE skillid = %s", fixsql(id))) do
    skill = {
      skillid = row.skillid,
      name = row.name,
      trainers = {},
    }
  end

  for row in db:nrows(string.format("SELECT * FROM skillstrain WHERE skillid = %s", fixsql(id))) do
    skill.trainers[#skill.trainers + 1] = row.mobid
  end

  return skill
end


function add_mob_to_locations_cache(mob)
  mobs_locations_cache[mob.mobid] = {}

  local loc

  for i = 1, #mob.locations do
    loc = mob.locations[i]

    mobs_locations_cache[mob.mobid][(loc.area or "") .. '|' .. (loc.room or "")] = {
      hits = loc.hits or 0,
      changed = false,
    }
  end
end


function add_item_to_locations_cache(item)
  items_locations_cache[item.itemid] = {}

  local loc

  for i = 1, #item.locations do
    if (area ~= "") or (room ~= "") then
      loc = item.locations[i]

      items_locations_cache[item.itemid][(loc.area or "") .. '|' .. (loc.room or "")] = {
        hits = loc.hits or 0,
        changed = false,
      }
    end
  end
end


function load_area_hits(zone)
  load_mobs_hits(zone)
  load_items_hits(zone)
end


function load_mobs_hits(zone)
  -- mobs_n_items: loading mobs locations hits for the area... --

  mobs_locations_cache = {}

  for row in db:nrows(string.format("SELECT * FROM mobsloc WHERE area = %s", fixsql(zone))) do
    if (not mobs_locations_cache[row.mobid]) then
      mobs_locations_cache[row.mobid] = {}
    end

    mobs_locations_cache[row.mobid][(row.area or "") .. '|' .. (row.room or "")] = {
      hits = row.hits or 0,
      changed = false,
    }
  end
end


function load_items_hits(zone)
  Note("-- mobs_n_items: loading items locations hits for the area... --")

  items_locations_cache = {}

  for row in db:nrows(string.format("SELECT * FROM itemsloc WHERE area = %s", fixsql(zone))) do
    if (row.area ~= "") or (row.room ~= "") then
      if (not items_locations_cache[row.itemid]) then
        items_locations_cache[row.itemid] = {}
      end

      items_locations_cache[row.itemid][(row.area or "") .. '|' .. (row.room or "")] = {
        hits = row.hits or 0,
        changed = false,
      }
    end
  end
end



------------------------------
-- add NPCs / items / skills
------------------------------

function add_mob_c(name, line, wildcards)
  local id = wildcards.id
  local name = wildcards.name
  local long = wildcards.long
  add_mob(id, name, long, false)
end


function add_mob(mobid, name, long_desc, auto)
  local mob = load_mob_from_database(mobid)

  if (mob) then
    if (name == mob.name) and (long_desc == mob.long_desc) then
      if (not auto) then
        ColourNote("red", "black", "-- mobs_n_items: the NPC #" .. mobid .. " is already in my db --")
      end

      mobid = nil

    else
      update_mob_database_info(mobid, name, long_desc)
    end

  else
    save_mob_to_database(mobid, name, long_desc)
  end

  return mobid
end


function add_item_c(name, line, wildcards)
  local id = wildcards.id
  local name = wildcards.name
  local long = wildcards.long
  add_item(id, name, long, false)
end


function add_item(itemid, name, long_desc, auto)
  local item = load_item_from_database(itemid)

  if (item) then
    if (name == item.name) and (long_desc == item.long_desc) then
      if (not auto) then
        ColourNote("red", "black", "-- mobs_n_items: the item #" .. itemid .. " is already in my db --")
      end

      itemid = nil

    else
      update_item_database_info(itemid, name, long_desc)
    end

  else
    save_item_to_database(itemid, name, long_desc)
  end

  return itemid
end


function add_skill(name, line, wildcards)
  local skillid = wildcards.id
  local name = wildcards.name

  local skill = load_skill_from_database(skillid)

  if (skill) then
    if (name == skill.name) then
--      ColourNote("red", "black", "-- mobs_n_items: the skill/spell #" .. skillid .. " is already in my db --")
      skillid = nil

    else
      update_skill_database_info(skillid, name)
    end

  else
    save_skill_to_database(skillid, name)
  end

  return skillid
end


function save_mob_to_database(mobid, name, long_desc)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "INSERT INTO mobs(mobid, name, long_desc, date_added) VALUES(%s, %s, %s, DATETIME('NOW'));",
       fixsql(mobid),
       fixsql(name),
       fixsql(long_desc)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: added NPC #" .. mobid .. ": " .. name .. " to db --")
end


function save_item_to_database(itemid, name, long_desc)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "INSERT INTO items(itemid, name, long_desc, date_added) VALUES(%s, %s, %s, DATETIME('NOW'));",
       fixsql(itemid),
       fixsql(name),
       fixsql(long_desc)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: added item #" .. itemid .. ": " .. name .. " to db --")
end


function save_skill_to_database(skillid, name)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "INSERT INTO skills(skillid, name, date_added) VALUES(%s, %s, DATETIME('NOW'));",
       fixsql(skillid),
       fixsql(name)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: added skill #" .. skillid .. ": " .. name .. " to db --")
end



---------------------------------
-- update NPCs / items / skills
---------------------------------

function update_mob_database_info(mobid, name, long_desc)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "UPDATE mobs SET name = %s, long_desc = %s WHERE mobid = %s;",
      fixsql(name),
      fixsql(long_desc),
      fixsql(mobid)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: updated db info for NPC #" .. mobid .. ": " .. name .. " --")
end


function update_item_database_info(itemid, name, long_desc)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "UPDATE items SET name = %s, long_desc = %s WHERE itemid = %s;",
      fixsql(name),
      fixsql(long_desc),
      fixsql(itemid)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: updated db info for item #" .. itemid .. ": " .. name .. " --")
end


function update_skill_database_info(skillid, name)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "UPDATE skills SET name = %s WHERE skillid = %s;",
      fixsql(name),
      fixsql(skillid)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: updated db info for skill #" .. skillid .. ": " .. name .. " --")
end



---------------------------------
-- delete NPCs / items / skills
---------------------------------

function del_mob(name, line, wildcards)
  local mobid = wildcards.id

  local mob = load_mob_from_database(mobid)

  if (mob) then
    del_mob_from_database(mobid)

  else
    ColourNote("red", "black", "-- mobs_n_items: the NPC #" .. mobid .. " isn't in my db --")
  end
end


function del_item(name, line, wildcards)
  local itemid = wildcards.id

  local item = load_item_from_database(itemid)

  if (item) then
    del_item_from_database(itemid)

  else
    ColourNote("red", "black", "-- mobs_n_items: the item #" .. itemid .. " isn't in my db --")
  end
end


function del_skill(name, line, wildcards)
  local skillid = wildcards.id

  local skill = load_skill_from_database(skillid)

  if (skill) then
    del_skill_from_database(skillid)

  else
    ColourNote("red", "black", "-- mobs_n_items: the skill/spell #" .. skillid .. " isn't in my db --")
  end
end


function del_mob_from_database(mobid)
  db:exec("BEGIN TRANSACTION;")

  -- delete NPC
  dbcheck(db:execute(string.format(
    "DELETE FROM mobs WHERE mobid = %s;",
      fixsql(mobid)
  )))

  -- delete locations
  dbcheck(db:execute(string.format(
    "DELETE FROM mobsloc WHERE mobid = %s;",
      fixsql(mobid)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: removed NPC #" .. mobid .. " from db --")
end


function del_item_from_database(itemid)
  db:exec("BEGIN TRANSACTION;")

  -- delete item
  dbcheck(db:execute(string.format(
    "DELETE FROM items WHERE itemid = %s;",
      fixsql(itemid)
  )))

  -- delete locations
  dbcheck(db:execute(string.format(
    "DELETE FROM itemsloc WHERE itemid = %s;",
      fixsql(itemid)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: removed item #" .. itemid .. " from db --")
end


function del_skill_from_database(skillid)
  db:exec("BEGIN TRANSACTION;")

  -- delete skill
  dbcheck(db:execute(string.format(
    "DELETE FROM skills WHERE skillid = %s;",
      fixsql(skillid)
  )))

  -- delete trainers
  dbcheck(db:execute(string.format(
    "DELETE FROM skillstrain WHERE skillid = %s;",
      fixsql(skillid)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: removed skill #" .. skillid .. " from db --")
end



------------------
-- add locations
------------------

function add_mob_location_c(name, line, wildcards)
  local mobid = wildcards.mobid
  local area = wildcards.area
  local room = wildcards.room
  add_mob_location(mobid, area, room, false)
end


function add_mob_location(mobid, area, room, auto)
  local res = {}

  if (tonumber(room)) or (area ~= "") then
    for row in db:nrows(string.format("SELECT * FROM mobsloc WHERE mobid = %s", fixsql(mobid))) do
      if (string.upper(room) == string.upper(row.room))
      and (string.upper(area) == string.upper(row.area)) then
        res[#res + 1] = row.mobid
      end
    end

    if (#res > 0) then
      if (not auto) then
        ColourNote("red", "black", "-- mobs_n_items: the NPC location is already in my db --")
      end

    else
      save_mob_location_to_database(mobid, area, room, 1)
    end

  else
    ColourNote("red", "black", "-- mobs_n_items: please provide either a room #, or [an] area [+ room] name[s] --")
  end
end


function add_item_location_c(name, line, wildcards)
  local itemid = wildcards.itemid
  local area = wildcards.area
  local mobid = wildcards.mobid
  local room = wildcards.room
  add_item_location(itemid, area, mobid, room, false)
end


function add_item_location(itemid, area, mobid, room, auto)
  local res = {}

  if (mobid) or (tonumber(room)) or (area ~= "") then
    for row in db:nrows(string.format("SELECT * FROM itemsloc WHERE itemid = %s", fixsql(itemid))) do
      if (mobid == row.mobid)
      and (string.upper(area) == string.upper(row.area))
      and (string.upper(room) == string.upper(row.room)) then
        res[#res + 1] = row.itemid
      end
    end

    if (#res > 0) then
      if (not auto) then
        ColourNote("red", "black", "-- mobs_n_items: the item location is already in my db --")
      end

    else
      save_item_location_to_database(itemid, area, mobid, room, 1)
    end

  else
    ColourNote("red", "black", "-- mobs_n_items: please provide either a npc_id, or a room #, or [an] area [+ room] name[s] --")
  end
end


function add_skill_trainer(name, line, wildcards)
  local skillid = wildcards.skillid
  local mobid = wildcards.mobid

  local res = {}

  if (tonumber(skillid)) then -- sanity check, is it a # or a name?
    if (tonumber(mobid)) then
      for row in db:nrows(string.format("SELECT * FROM skillstrain WHERE skillid = %s", fixsql(skillid))) do
        if (mobid == row.mobid) then
          res[#res + 1] = row.skillid
        end
      end

      if (#res > 0) then
--        ColourNote("red", "black", "-- mobs_n_items: the skill/spell trainer is already in my db --")

      else
        save_skill_trainer_to_database(skillid, mobid)
      end

    else -- mobid is not a number
      ColourNote("red", "black", "-- mobs_n_items: please provide an npc_id --")
    end

  else -- skillid is not a number
    ColourNote("yellow", "black", "-- mobs_n_items: skill_id must be a number! --")
  end
end


function save_mob_location_to_database(mobid, area, room, hits)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "INSERT INTO mobsloc(mobid, area, room, hits, date_added) VALUES(%s, %s, %s, %i, DATETIME('NOW'));",
       fixsql(mobid),
       fixsql(area),
       fixsql(room),
       hits
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: added location for mob #" .. mobid .. " to db --")
end


function save_item_location_to_database(itemid, area, mobid, room, hits)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "INSERT INTO itemsloc(itemid, area, mobid, room, hits, date_added) VALUES(%s, %s, %s, %s, %i, DATETIME('NOW'));",
       fixsql(itemid),
       fixsql(area),
       fixsql(mobid),
       fixsql(room),
       hits
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: added location for item #" .. itemid .. " to db --")
end


function save_skill_trainer_to_database(skillid, mobid)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "INSERT INTO skillstrain(skillid, mobid, date_added) VALUES(%s, %s, DATETIME('NOW'));",
       fixsql(skillid),
       fixsql(mobid)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: added location for skill #" .. skillid .. " to db --")
end



---------------------
-- update locations
---------------------

function update_hits()
  if (config.addMXP) then
    update_mobs_hits()
    update_items_hits()
  end
end


function update_mobs_hits()
  --print(serialize.save_simple(mobs_locations_cache))

  local t

  Note("-- mobs_n_items: updating mobs locations hits... --")

  db:exec("BEGIN TRANSACTION;")

  for mobid, val in pairs(mobs_locations_cache) do
    SetStatus("... updating locations hits for mob #" .. mobid .. "...")

    for where, hits in pairs(val) do
      if (hits.changed) then
        t = utils.split(where, "|")
        update_mob_locations_database_info(mobid, t[1], t[2], hits.hits)
      end
    end
  end

  db:exec("COMMIT;")

  SetStatus ("Ready")
  Note("... done!")
end


function update_items_hits()
  --print(serialize.save_simple(items_locations_cache))

  local t

  Note("-- mobs_n_items: updating items locations hits... --")

  db:exec("BEGIN TRANSACTION;")

  for itemid, val in pairs(items_locations_cache) do
    SetStatus("... updating locations hits for item #" .. itemid .. "...")

    for where, hits in pairs(val) do
      if (hits.changed) then
        t = utils.split(where, "|")
        update_item_locations_database_info(itemid, t[1], t[2], hits.hits)
      end
    end
  end

  db:exec("COMMIT;")

  SetStatus ("Ready")
  Note("... done!")
end


function update_mob_locations_database_info(mobid, area, room, hits)
  dbcheck(db:execute(string.format(
    "UPDATE mobsloc SET hits = %i WHERE mobid = %s AND area = %s AND room = %s;",
      hits,
      fixsql(mobid),
      fixsql(area),
      fixsql(room)
  )))
end


function update_item_locations_database_info(itemid, area, room, hits)
  dbcheck(db:execute(string.format(
    "UPDATE itemsloc SET hits = %i WHERE itemid = %s AND area = %s AND room = %s;",
      hits,
      fixsql(itemid),
      fixsql(area),
      fixsql(room)
  )))
end



---------------------
-- delete locations
---------------------

function del_mob_location(name, line, wildcards)
  local mobid = wildcards.mobid
  local area = wildcards.area
  local room = wildcards.room

  local res = {}

  for row in db:nrows(string.format("SELECT * FROM mobsloc WHERE mobid = %s", fixsql(mobid))) do
    if (string.upper(room) == string.upper(row.room))
    and (string.upper(area) == string.upper(row.area)) then
      res[#res + 1] = row.mobid
    end
  end

  if (#res > 0) then
    del_mob_location_from_database(mobid, area, room)

  else
    ColourNote("red", "black", "-- mobs_n_items: the NPC location is not in my db --")
  end
end


function del_item_location(name, line, wildcards)
  local itemid = wildcards.itemid
  local area = wildcards.area
  local mobid = wildcards.mobid
  local room = wildcards.room

  local res = {}

  for row in db:nrows(string.format("SELECT * FROM itemsloc WHERE itemid = %s", fixsql(itemid))) do
    if (mobid == row.mobid)
    and (string.upper(room) == string.upper(row.room))
    and (string.upper(area) == string.upper(row.area)) then
      res[#res + 1] = row.mobid
    end
  end

  if (#res > 0) then
    del_item_location_from_database(itemid, area, mobid, room)

  else
    ColourNote("red", "black", "-- mobs_n_items: the item location is not in my db --")
  end
end


function del_skill_trainer(name, line, wildcards)
  local skillid = wildcards.skillid
  local mobid = wildcards.mobid

  local res = {}

  for row in db:nrows(string.format("SELECT * FROM skillstrain WHERE skillid = %s", fixsql(skillid))) do
    if (mobid == row.mobid) then
      res[#res + 1] = row.mobid
    end
  end

  if (#res > 0) then
    del_skill_trainer_from_database(skillid, mobid)

  else
    ColourNote("red", "black", "-- mobs_n_items: the trainer is not in my db --")
  end
end


function del_mob_location_from_database(mobid, area, room)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format([[
    DELETE FROM mobsloc WHERE mobid = %s AND UPPER(area) = %s AND room = %s;
  ]], fixsql(mobid),
      fixsql(string.upper(area)),
      fixsql(room)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: deleted location for mob #" .. mobid .. " from db --")
end


function del_item_location_from_database(itemid, area, mobid, room)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format([[
    DELETE FROM itemsloc WHERE itemid = %s AND UPPER(area) = %s AND mobid = %s AND room = %s;
  ]], fixsql(itemid),
      fixsql(string.upper(area)),
      fixsql(mobid),
      fixsql(room)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: deleted location for item #" .. itemid .. " from db --")
end


function del_skill_trainer_from_database(skillid, mobid)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format([[
    DELETE FROM skillstrain WHERE skillid = %s AND mobid = %s;
  ]], fixsql(skillid),
      fixsql(mobid)
  )))

  db:exec("COMMIT;")

  Note("-- mobs_n_items: deleted trainer for skill #" .. skillid .. " from db --")
end



---------------------
-- database queries
---------------------

local fontcol = "silver"
local bgcol = "black"
local areacol = "white"
local namecol = "palevioletred" -- springgreen
local mobcol = fontcol


function find_npc_strict(name, line, wildcards)
  local name = wildcards.name
  local area = wildcards.area
  find_npc(name, area, false)
end


function find_npc_fuzzy(name, line, wildcards)
  local name = wildcards.name
  local area = wildcards.area
  find_npc(name, area, true)
end


function find_npc(name, area, fuzzy)
  local results = {}

  local cmd
  if (fuzzy) then
    name = "%" .. name .. "%"
    cmd = "SELECT mobid FROM mobs WHERE UPPER(name) LIKE %s"
  else
    cmd = "SELECT mobid FROM mobs WHERE UPPER(name) = %s"
  end

  for row in db:nrows(string.format(cmd, string.upper(fixsql(name)))) do
    results[#results + 1] = row.mobid
  end

  ColourTell("lightgreen", "black", "Results for: '" .. name .. "'")
  if (area ~= "") then
    ColourNote("lightgreen", "black", " in the area: '" .. area .. "':")
  else
    ColourNote("lightgreen", "black", ":")
  end

  for i = 1, #results do
    show_npc_info(results[i], area)
  end

  if (area ~= "") then
    ColourTell("lightgreen", "black", "Click ")
    Hyperlink("mob wheree " .. name, "[here]", "", "lightgreen", "black", false)
    ColourNote("lightgreen", "black", " or type 'mob wheree " .. name .. "' to repeat the search without area restrictions.")
  end
end


function find_item_strict(name, line, wildcards)
  local name = wildcards.name
  local area = wildcards.area
  find_item(name, area, false)
end


function find_item_fuzzy(name, line, wildcards)
  local name = wildcards.name
  local area = wildcards.area
  find_item(name, area, true)
end


function find_item(name, area, fuzzy)
  local results = {}

  local cmd
  if (fuzzy) then
    name = "%" .. name .. "%"
    cmd = "SELECT itemid FROM items WHERE UPPER(name) LIKE %s"
  else
    cmd = "SELECT itemid FROM items WHERE UPPER(name) = %s"
  end

  for row in db:nrows(string.format(cmd, string.upper(fixsql(name)))) do
    results[#results + 1] = row.itemid
  end

  ColourTell("lightgreen", "black", "Results for: '" .. name .. "'")
  if (area ~= "") then
    ColourNote("lightgreen", "black", " in the area: '" .. area .. "':")
  else
    ColourNote("lightgreen", "black", ":")
  end

  for i = 1, #results do
    show_item_info(results[i], area)
  end

  if (area ~= "") then
    ColourTell("lightgreen", "black", "Click ")
    Hyperlink("item wheree " .. name, "[here]", "", "lightgreen", "black", false)
    ColourNote("lightgreen", "black", " or type 'item wheree " .. name .. "' to repeat the search without area restrictions.")
  end
end


function find_skill_strict(name, line, wildcards)
  local name = wildcards.name
  local area = wildcards.area
  find_skill(name, area, false)
end


function find_skill_fuzzy(name, line, wildcards)
  local name = wildcards.name
  local area = wildcards.area
  find_skill(name, area, true)
end


function find_skill(name, area, fuzzy)
  local results = {}

  local cmd
  if (fuzzy) then
    name = "%" .. name .. "%"
    cmd = "SELECT skillid FROM skills WHERE UPPER(name) LIKE %s"
  else
    cmd = "SELECT skillid FROM skills WHERE UPPER(name) = %s"
  end

  for row in db:nrows(string.format(cmd, string.upper(fixsql(name)))) do
    results[#results + 1] = row.skillid
  end

  ColourTell("lightgreen", "black", "Trainers for: '" .. name .. "'")
  if (area ~= "") then
    ColourNote("lightgreen", "black", " in the area: '" .. area .. "':")
  else
    ColourNote("lightgreen", "black", ":")
  end

  for i = 1, #results do
    show_skill_info(results[i], area)
  end

  if (area ~= "") then
    ColourTell("lightgreen", "black", "Click ")
    Hyperlink("skill wheree " .. name, "here", "", "lightgreen", "black", false)
    ColourNote("lightgreen", "black", " or type 'skill wheree " .. name .. "' to repeat the search without area restrictions.")
  end
end


function show_npc_info(id, area)
  local npc = load_mob_from_database(id)
  local previous_area = nil
  local area_changed = true

  area = Trim(area)

  if (npc) then -- npc is in the db
    if (area ~= "") then
      for i = #npc.locations, 1, -1 do
        if (string.lower(area) ~= string.lower(npc.locations[i].area)) then
          table.remove(npc.locations, i)
        end
      end
    end

    if (#npc.locations > 0) then
      Note("")
      Tell("npc: ")
      ColourTell(namecol, bgcol, npc.name)

      Tell(" - id: ")
      ColourTell(fontcol, bgcol, npc.mobid)

--      Tell(" - long_desc: ")
--      ColourTell(fontcol, bgcol, npc.long_desc)

      if (area ~= "") then
        Tell(" - area: ")
        Hyperlink("gate " .. area, area, "", areacol, bgcol, false)

--        ColourTell(fontcol, bgcol, area)
      end

      if (#npc.roomnums > 0) then
        for i = 1, #npc.roomnums do
          Tell(" - ")
          Execute("mapper hyper " .. npc.roomnums[i])
        end

      else
        for i = 1, #npc.locations do
          if (area == "") then
            if (not previous_area) or (previous_area ~= npc.locations[i].area) then
              Tell("\r\n- area: ")
            Hyperlink("gate " .. npc.locations[i].area, npc.locations[i].area, "", areacol, bgcol, false)
              previous_area = npc.locations[i].area
              area_changed = true
            else
              area_changed = false
            end
          end

          if (npc.locations[i].room ~= "")
          and (npc.locations[i].room ~= "?")
          and (npc.locations[i].room ~= "-") then
            Tell(" - room: ")

            if (area ~= "") then
              Hyperlink("mapper wheree " .. npc.locations[i].room .. " a:" .. area, npc.locations[i].room, "", fontcol, bgcol, false)
            else
              Hyperlink("mapper wheree " .. npc.locations[i].room, npc.locations[i].room, "", fontcol, bgcol, false)
            end
          end

          if (npc.locations[i].hits) and (npc.locations[i].hits > 0) then
            Tell(" (" .. npc.locations[i].hits .. " hit(s))")
          end
        end

        Note("")
      end

    end

  else
    ColourNote("red", "black", "-- mobs_n_items: the NPC " .. id .. " isn't in my db --")
  end
end


function show_item_info(id, area)
  local item = load_item_from_database(id)
  local previous_area = nil
  local area_changed = true

  area = Trim(area)

  if (item) then -- item is in the db

    if (area ~= "") then
      for i = #item.locations, 1, -1 do
        if (string.lower(area) ~= string.lower(item.locations[i].area)) then
          table.remove(item.locations, i)
        end
      end
    end

    if (#item.locations > 0) then
      Note("")
      Tell("item: ")
      ColourTell(namecol, bgcol, item.name)

      Tell(" - id: ")
      ColourTell(fontcol, bgcol, item.itemid)

  --    Tell(" - long_desc: ")
  --    ColourTell(fontcol, bgcol, item.long_desc)

      if (area ~= "") then
        Tell("\r\n - area: ")
        Hyperlink("gate " .. area, area, "", areacol, bgcol, false)
      end

      for i = 1, #item.locations do
        if (area == "") then
          if (not previous_area) or (previous_area ~= item.locations[i].area) then
            Tell("\r\n - area: ")
            Hyperlink("gate " .. item.locations[i].area, item.locations[i].area, "", areacol, bgcol, false)
            previous_area = item.locations[i].area
            area_changed = true
          else
            area_changed = false
          end
        end

        if (item.locations[i].mobid ~= "") then
          mob = load_mob_from_database(item.locations[i].mobid)

          if (area_changed) then
            Tell(" - on mob(s): ")
          else
            Tell(", ")
          end

          if (area ~= "") then
            Hyperlink("mob wheree " .. mob.name .. " a:" .. area, mob.name, "", mobcol, bgcol, false)
          elseif (item.locations[i].area) then
            Hyperlink("mob wheree " .. mob.name .. " a:" .. item.locations[i].area, mob.name, "", mobcol, bgcol, false)
          else
            Hyperlink("mob wheree " .. mob.name, mob.name, "", mobcol, bgcol, false)
          end

        elseif (item.locations[i].room ~= "") then
          Tell(" - in room: ")
          if (area ~= "") then
            Hyperlink("mapper wheree " .. item.locations[i].room .. " a:" .. area, item.locations[i].room, "", fontcol, bgcol, false)
          else
            Hyperlink("mapper wheree " .. item.locations[i].room, item.locations[i].room, "", fontcol, bgcol, false)
          end

          if (item.locations[i].hits) and (item.locations[i].hits > 0) then
            Tell(" (" .. item.locations[i].hits .. " hit(s))")
          end
        end
      end

      Note("")
    end

  else
    ColourNote("red", "black", "mobs_n_items: the item " .. id .. " isn't in my db --")
  end
end


function show_skill_info(id, area)
  local skill = load_skill_from_database(id)

  area = Trim(area)

  if (skill) then -- skill is in the db
    Note("")
    Tell("skill: ")
    ColourTell(namecol, bgcol, skill.name)

    Tell(" - id: ")
    ColourTell(fontcol, bgcol, skill.skillid)

    if (area ~= "") then
      Tell(" - area: ")
      Hyperlink("gate " .. area, area, "", areacol, bgcol, false)
    end

    local trainer

--    print(serialize.save_simple(skill))

    if (area ~= "") then
      for i = #skill.trainers, 1, -1 do
        trainer = load_mob_from_database(skill.trainers[i])

--        print(serialize.save_simple(trainer))

        if (#trainer.locations > 0) then
          if (string.lower(area) ~= string.lower(trainer.locations[1].area)) then -- trainer isn't in the chosen area
            table.remove(skill.trainers, i)
          end

        else -- we don't know where the trainer is
          table.remove(skill.trainers, i)
        end
      end
    end

    if (#skill.trainers > 0) then
      Tell(", trained by:")
    end

    for i = 1, #skill.trainers do
      trainer = load_mob_from_database(skill.trainers[i])

--      print(serialize.save_simple(trainer))

      if (i == 1) then
        Tell(" ")
      else
        Tell(", ")
      end

      if (area ~= "") then
        Hyperlink("mob wheree " .. trainer.name .. " a:" .. area, trainer.name, "", fontcol, bgcol, false)
      else
        Hyperlink("mob wheree " .. trainer.name, trainer.name, "", fontcol, bgcol, false)
        Tell(" in " .. trainer.locations[1].area)
      end
    end
    Note("")

  else
    ColourNote("red", "black", "mobs_n_items: the skill " .. id .. " isn't in my db --")
  end
end


function get_npc_areas(mob_name)
  local sname = fixsql(string.upper(mob_name))
  local mob_ids = {}

--  print(sname)

  for row in db:nrows(string.format("SELECT mobid FROM mobs WHERE UPPER(name) = %s", sname)) do
    mob_ids[#mob_ids + 1] = row.mobid
  end -- finding rooms

--  print(serialize.save_simple(mob_ids))

  local t = {}

  for i = 1, #mob_ids do
    for row in db:nrows(string.format("SELECT area FROM mobsloc WHERE mobid = %s", fixsql(mob_ids[i]))) do
      t[#t + 1] = row.area
    end
  end

--  print(serialize.save_simple(t))

  return table.concat(t, ";")
end


function get_item_areas(item_name)
  local sname = fixsql(string.upper(item_name))
--  print(sname)

  local item_ids = {}

  for row in db:nrows(string.format("SELECT itemid FROM items WHERE UPPER(name) = %s", sname)) do
    item_ids[#item_ids + 1] = row.itemid
  end -- finding rooms

--  print(serialize.save_simple(item_ids))

  local t = {}

  for i = 1, #item_ids do
    for row in db:nrows(string.format("SELECT area FROM itemsloc WHERE itemid = %s", fixsql(item_ids[i]))) do
      t[#t + 1] = row.area
    end
  end

--  print(serialize.save_simple(t))

  return table.concat(t, ";")
end


]]>

</script>

</muclient>
