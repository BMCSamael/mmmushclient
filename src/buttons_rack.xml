<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, May 03, 2012, 5:58 PM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "buttons_rack" generated by Plugin Wizard -->

<muclient>

<plugin
   name="buttons_rack"
   author="Ruthgul"
   id="366aa79676f9fb1941eb5f69"
   language="Lua"
   purpose="rack for clickable buttons"
   save_state="y"
   date_written="2012-05-03 17:57:37"
   date_modified="2013-07-05 10:45:52"
   requires="4.71"
   version="1.0"
   >

<description trim="y">

<![CDATA[

.----------------.
 | buttons_rack |
`----------------'

It creates a rack where you can add clickable buttons for actions.

- The rack is draggable (from its title) to whatever position you want on screen.

- The rack will auto-grow or shrink as you add/remove buttons. It currently doesn't have a max limit, so if you add too many buttons they'll run off screen.

- It supports (and enforces) personalized racks for each different char that you play.


** REQUIRES **

- MM_GMCP_Handler (plugin id="f67c4339ed0591a5b010d05b") must be installed and enabled.
- detect_globals (plugin id="d900cb999816b1f6f2d4bdc5") must be installed and enabled.
- global_vars (plugin id="97784abf5f30629a0d7e7307") must be installed and enabled.


Syntax:

* rack hide  - hides the rack
* rack show  - shows the rack

* rack add button <title> a:<action>  - adds a button to the rack (example: rack add button TERRAIN a:mapper show terrain)
Notes:
  - title must be a single word, or 2+ words separated with spaces or underscores
  - action can be either a game command, or a MUSHclient alias, and must be preceded by a:

* rack edit button <title> a:<new_action>  - changes the action for a previously created button

* rack del button <title>  - deletes a button from the rack (example: rack del button TERRAIN)

* rack list buttons  - shows a list of buttons with their assigned actions


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Aliases -->

<aliases>

<!-- rack -->

  <alias
   match="^rack[ ]+show$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  rack_show()
else
  plugin_not_initialized()
end
</send>
  </alias>


  <alias
   match="^rack[ ]+hide$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  rack_hide()
else
  plugin_not_initialized()
end
</send>
  </alias>


<!-- buttons -->

  <alias
   match="^rack[ ]+add[ ]+button[ ]+(?P&lt;title&gt;[a-zA-Z0-9 \_]+) a\:(?P&lt;action&gt;[a-zA-Z0-9 \.\,\'\#]*)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  button_add("%&lt;title&gt;", "%&lt;action&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>


  <alias
   match="^rack[ ]+edit[ ]+button[ ]+(?P&lt;title&gt;[a-zA-Z0-9 \_]+) a\:(?P&lt;new_action&gt;[a-zA-Z0-9 \.\,\'\#]*)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  button_edit("%&lt;title&gt;", "%&lt;new_action&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>


  <alias
   match="^rack[ ]+del[ ]+button[ ]+(?P&lt;title&gt;[a-zA-Z0-9 \_]+)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  button_del("%&lt;title&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>


  <alias
   match="^rack[ ]+list[ ]+buttons$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  show_buttons_list()
else
  plugin_not_initialized()
end
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^buttons_rack(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Triggers  -->

<triggers>

<!-- on first prompt -->

  <trigger
   enabled="y"
   name="first_prompt"
   keep_evaluating="y"
   match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)) $"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>on_first_prompt()
</send>
  </trigger>

</triggers>



<!--  Scripts  -->


<script>

<![CDATA[

require "movewindow"
require "gauge"

width = 120
height = 600

font = "Trebuchet MS"
fontsize = 9

bgcol = ColourNameToRGB("gray")
txtcol = ColourNameToRGB("black")
titletxtcol = ColourNameToRGB("maroon")
titlebordercol = ColourNameToRGB("gray")
bordercol = ColourNameToRGB("black ")
buttonbgcol = ColourNameToRGB("silver")
pressbuttonbgcol = ColourNameToRGB("darkgray")


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  Tell("-- " .. GetPluginInfo(GetPluginID (), 1) .. ": type ")
  ColourTell("silver", "black", GetPluginInfo(GetPluginID (), 1) .. " help")
  Note(" to see info about this plugin --")

  EnableTrigger("first_prompt", true)
  name = nil
end


function OnPluginClose()
  if (name) then
    movewindow.save_state(irack)
    WindowShow(irack, false)  -- hide window on removal
  end
end


function OnPluginDisable()
  if (name) then
    WindowShow(irack, false)  -- hide window on disable
  end
end


function OnPluginSaveState()
  if (name) then
    movewindow.save_state(irack)
  end
end


function OnPluginConnect()
  EnableTrigger("first_prompt", true)
  name = nil
end


function OnHelp ()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID (), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo (GetPluginID(), 14)) .. ")")
end


function plugin_not_initialized()
  Note("-- " .. GetPluginInfo(GetPluginID (), 1) .. ": plugin initialization unfinished --")
  Note("please wait 5 seconds and try again")
end


function show_message(msg)
  Note("-- " .. GetPluginInfo(GetPluginID (), 1) .. ": " .. msg .. " --")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/buttons_rack.xml",
  }
  return (table.concat(t, ";"))
end



---------
-- name
---------

function on_first_prompt()
  EnableTrigger("first_prompt", false)

  do_get_name()
end


function OnPluginBroadcast(msg, id, pname, text)
  if (id =="97784abf5f30629a0d7e7307")
  and (pname == "global_vars") then -- global_vars
    if (msg == 1) and (text == "name") then
      -- name broadcasted
      do_get_name()
    end
  end
end


function do_get_name()
  name = get_global_var("name")

  if (name) then
    got_name()
  end
end


function get_global_var(name)
  local res, val

  res, val = CallPlugin("97784abf5f30629a0d7e7307", "get_global_var", name)

  if (res ~= 0) then
    val = nil
  end

  return val
end


function got_name()
  load_tables()
  rack_start()
end



-----------------
-- window stuff
-----------------

function rack_start()
  irack = "irack_" .. GetPluginID()

  WindowCreate (irack, 0, 0, 0, 0, 0, 0, 0)
  WindowFont(irack, "frack", font, fontsize, true, false, false, false)
  font_height = WindowFontInfo(irack, "frack", 1)

  windowinfo = movewindow.install(irack, miniwin.pos_top_center)
  rack_redraw()
end


function rack_redraw()
  WindowShow(irack, false)

  height = 35 + (#buttons * 20)
  if (height < 70) then
    height = 55 -- minimum height
  end

  WindowCreate(irack, windowinfo.window_left, windowinfo.window_top, width, height, windowinfo.window_mode, windowinfo.window_flags, bgcol)

  show_title("~ mathoms rack ~")

  show_all_buttons()

  WindowShow(irack, true)
end


function rack_show()
  WindowShow(irack, true)
end


function rack_hide()
  WindowShow(irack, false)
end


function show_title(title)
  local txtwidth = WindowTextWidth(irack, "frack", title, true)
  local wherex = (width - txtwidth) / 2

  draw_text_box(irack,
                "frack",
                wherex,
                2,
                title,
                false,
                titletxtcol,
                bgcol,
                titlebordercol)

  -- let them move it around
  movewindow.add_drag_handler(irack, wherex, 0, wherex + txtwidth, 20, 10)
end


function show_all_buttons()
  -- draw the 3D box that will contain all buttons
  draw_3d_box(irack, 2, 25, width - 4, height - 27)

  for i = 1, #buttons do
    show_button(i)
  end
end


function show_button(num)
  local wherey, wherextxt = calc_button_pos(num)

  draw_button(num, wherey, wherextxt, buttonbgcol)

  -- add hotspot
  if (actions[num] ~= "") then
    WindowAddHotspot(irack, buttons[num], 8, wherey, width - 8, wherey + font_height, "", "", "mousedown", "cancelmousedown", "mouseup", title, 1, 0)
  end
end


function calc_button_pos(num)
  local txtwidth = WindowTextWidth(irack, "frack", buttons[num], true)
  local wherextxt = (width - txtwidth) / 2
  local wherey = 10 + (num * 20)

  return wherey, wherextxt
end


function draw_button(num, wherey, wherextxt, bckgrcol)
  -- show button
  WindowRectOp(irack, 2, 8, wherey, width - 8, wherey + font_height, bckgrcol)

  -- show button's title
  if (buttons[num] ~= "") then
    WindowText(irack, "frack", buttons[num], wherextxt, wherey, 0, 0, txtcol, true)
  end

  -- show border
  WindowRectOp(irack, 1, 7, wherey, width - 7, wherey + font_height, bordercol)
end


function redraw_button(title, pressed)
  local i = find_index(cmd)

  if (i) then -- there actually is a button by that title
--    Note("redrawing button #" .. i .. " as " .. how)
    local wherey, wherextxt = calc_button_pos(i)

    local bckgrndcol
    if (pressed) then
      bckgrndcol = pressbuttonbgcol
    else -- default is "released"
      bckgrndcol = buttonbgcol
    end

    draw_button(i, wherey, wherextxt, bckgrndcol)

    WindowShow(irack, true) -- refresh window
  end
end



-------------------
-- hotspots stuff
-------------------

function mousedown(flags, hs_id)
  cmd = nil
  if (flags == miniwin.hotspot_got_lh_mouse) then
    cmd = hs_id -- just click

    redraw_button(cmd, true)
  end
end


function cancelmousedown(flags, hs_id)
  if (cmd) then
    redraw_button(cmd, false)

    cmd = nil
  end
end


function mouseup(flags, hs_id)
  if (cmd) then -- not nil
    redraw_button(cmd, false)

    local i = find_index(cmd)

    if (i) then -- there actually is a button by that title
      local action = actions[i]
      if (action ~= "") then
        Execute(action)
      end
    end
  end
end


------------------
-- buttons stuff
------------------

function button_add(title, action)
  local i = find_index(title)

  if (not i) then -- there isn't a button by that name, so we can add it ok
    buttons[#buttons + 1] = title
    actions[#actions + 1] = action
    save_tables()
    rack_redraw()
    show_message("'" .. title .. "' button added")

  else -- button already exists
    show_message("there's already a button by that name!")
  end
end


function button_edit(title, new_action)
  local i = find_index(title)

  if (not i) then -- button doesn't exist
    show_message("there isn't a button by that name!")

  else -- button exists
    actions[i] = new_action
    save_tables()
    rack_redraw()
    show_message("'" .. title .. "' button changed")
  end
end


function button_del(title)
  local i = find_index(title)

  if (not i) then -- button doesn't exist
    show_message("there isn't a button by that name!")

  else -- button exists
    table.remove(buttons, i)
    table.remove(actions, i)
    save_tables()
    rack_redraw()
    show_message("'" .. title .. "' button deleted")
  end
end


function show_buttons_list()
  show_message("listing all buttons")
  for i = 1, #buttons do
    Tell("* ")
    ColourTell("silver", "black", buttons[i])
    Tell(" performs the action: '")
    ColourTell("silver", "black", actions[i])
    Note("'")
  end
end



-----------------
-- tables stuff
-----------------

function find_index(title)
  res = nil

  for i = 1, #buttons do
    if (buttons[i] == title) then
      res = i
      break
    end
  end

  return res
end


function save_tables()
  if (name) then
    SetVariable(name .. "_buttons", table.concat(buttons, ","))
    SetVariable(name .. "_actions", table.concat(actions, ","))
    SaveState()
  end
end


function load_tables()
  if (name) then
    local aux_buttons = GetVariable(name .. "_buttons") or ""
    local aux_actions = GetVariable(name .. "_actions") or ""

    if (aux_buttons == "") then
      buttons = {}
      actions = {}

    else
      buttons = utils.split(aux_buttons, ",")
      actions = utils.split(aux_actions, ",")
    end
  end
end


]]>

</script>

</muclient>
