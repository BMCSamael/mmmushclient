<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, November 24, 2013, 9:29 AM -->
<!-- MuClient version 4.90 -->

<!-- Plugin "meh_timers" generated by Plugin Wizard -->

<muclient>

<plugin
   name="meh_timers"
   author="Ruthgul"
   id="a11c9d4e484b5fc428a49941"
   language="Lua"
   purpose="countdown timers and alarms"
   save_state="y"
   date_written="2013-11-24 09:28:43"
   date_modified="2014-01-04 15:15:37"
   requires="4.71"
   version="1.0"
   >

<description trim="y">

<![CDATA[

.--------------.
 | meh_timers |
`--------------'

- Lets you add non-persistent countdown timers and alarm times.
- Shows a message when one of them hits 0 seconds, and makes noise if possible.


** REQUIRES **

- Sapi_speaker or Text-To-Speech (plugin id = 463242566069ebfd1b379ec1, by Nick Gammon) must be installed and enabled for this script to be able to say stuff.
- play_sounds (plugin id = 4327c10cd9ae383bef04a7fc) must be installed and enabled for this script to be able to play a sound file.


Syntax:

* set alarm <hh>:<mm> [<reason>]  - sets an alarm that will trigger at the said time; the hour must be written in 24-hour format (eg: set alarm 22:15 check for trunk)

* set countdown [<hh>h] [<mm>m] [<ss>s] [<reason>]  - sets a countdown timer that will trigger when the specified time has passed (eg: set countdown 20m repop)

* alarm sound <file_name>  - sets a WAV or MP3 file to play when a timer reaches 0 seconds (requires the play_sounds plugin, and the file to be placed in your mushclient/sounds folder)

* list timers  - shows a list of all timers and alarms maintained by this script


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Aliases  -->

<aliases>

  <alias
   match="^set[ ]+alarm[ ]+(?P&lt;hh&gt;[0-9]+)\:(?P&lt;mm&gt;[0-9]+)(|[ ]+(?P&lt;reason&gt;.+))$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>set_alarm("%&lt;hh&gt;", "%&lt;mm&gt;", "%&lt;reason&gt;", "set alarm alias")
</send>
  </alias>

  <alias
   match="^set[ ]+countdown(|[ ]+(?P&lt;hh&gt;[0-9]+)h)(|[ ]+(?P&lt;mm&gt;[0-9]+)m)(|[ ]+(?P&lt;ss&gt;[0-9]+)s)(|[ ]+(?P&lt;reason&gt;[a-zA-z](.*?)))$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>set_countdown("%&lt;hh&gt;", "%&lt;mm&gt;", "%&lt;ss&gt;", "%&lt;reason&gt;", "set countdown alias")
</send>
  </alias>

  <alias
   match="^alarm[ ]+sound[ ]+(?P&lt;file_name&gt;.+)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>set_sound("%&lt;file_name&gt;")
</send>
  </alias>

  <alias
   match="^list[ ]+timers$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>list_timers()
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   script="OnHelp"
   match="^meh\_timers(|( |\:)help)$"
   regexp="y"
   enabled="y"
  >
  </alias>

</aliases>



<!-- Timers  -->

<timers>

  <timer
   enabled="y"
   second="1.00"
   offset_second="0.00"
   active_closed="y"
   send_to="12"
  >
  <send>check_timers()
</send>
  </timer>

</timers>



<!--  Scripts  -->

<script>

<![CDATA[

require "serialize"
require "wait"


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  wait.make(function()
    Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
    ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
    Note(" to see info about this plugin --")

    sound_file = GetVariable("sound_file")

    timers = {}

    -- give the plugins time to install
    wait.time(3)
    detect_plugins()
  end)
end


function OnPluginListChanged()
  detect_plugins()
end


function detect_plugins()
  use_events_mini = events_mini_installed()
  use_play_sounds = play_sounds_present()
  use_sapi = sapi_plugin_present()
end


function is_plugin_present(name, id)
  local res = false

  local plugin_name = GetPluginInfo(id, 1)

  if (plugin_name == name) then
    -- is it enabled?
    if (GetPluginInfo(id, 17)) then
      res = true
    end
  end

  return res
end


function OnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID(), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo(GetPluginID(), 14)) .. ")")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/meh_timers.xml",
  }
  return (table.concat(t, ";"))
end



-----------------
-- config stuff
-----------------

function set_sound(file_name)
  -- check if the file exists
  local path = GetInfo(66) .. "sounds\\"

  local f = io.open(path .. file_name, "r")

  if (f) then
    f:close()
    do_set_sound(file_name)

  else
    ColourNote("tomato", "black", "-- meh_timers: the file " .. path .. file_name .. " doesn't exist --")
  end
end


function do_set_sound(file_name)
  sound_file = file_name
  SetVariable("sound_file", file_name)
  SaveState()

  Note("-- meh_timers: " .. file_name .. " chosen as alarm sound --")
end



---------------
-- add timers
---------------

function set_alarm(hh, mm, reason, who)
  hh = tonumber(hh)
  mm = tonumber(mm)

  if (mm >= 0) and (mm <= 59)
  and (hh >= 0) and (hh <= 23) then
    local seconds = hms_to_sec(hh, mm, 0)

    local current_seconds = current_time_of_day_as_sec()

    local alarm_seconds = seconds - current_seconds

    if (alarm_seconds < 0) then
    -- tomorrow => we add 24 hours
      alarm_seconds = alarm_seconds + (24 * 60 * 60)
    end

    reason = Trim(reason)

    timers[#timers + 1] = {
      time = os.time() + alarm_seconds,
      text = reason,
      owner = Trim(who or ""),
    }

    Tell("-- meh_timers: added alarm timer, will fire at ")
    show_newest_timer(alarm_seconds)
    Note(" from now) --")

  else
    ColourNote("tomato", "black", "-- meh_timers: you must specify a valid 24-hour time - eg, 14:30 --")
  end
end


function set_countdown(hh, mm, ss, reason, who)
  local seconds = hms_to_sec(hh, mm, ss)

  if (seconds) then
    do_set_countdown(seconds, reason, who)

    Tell("-- meh_timers: added countdown timer, will fire at ")
    show_newest_timer(seconds)
    Note(" from now) --")

  else
    ColourNote("tomato", "black", "-- meh_timers: you must specify a time - eg, 5h 10m 15s --")
  end
end


function set_unique_countdown(hh, mm, ss, reason, who)
  local seconds = hms_to_sec(hh, mm, ss)

  -- check all timers, see if any have text = the current reason,
  -- and their timer is bigger than this one
  -- case sensitive search
  local index

  for i = 1, #timers do
    if (timers[i].text == reason) then
      index = i
      break
    end
  end

  -- add or modify, silently
  if (not index) then
    do_set_countdown(seconds, reason, who)

  elseif (timers[index].time < (os.time() + seconds)) then
    timers[index].time = os.time() + seconds
  end
end


function do_set_countdown(seconds, reason, who)
  reason = Trim(reason)

  timers[#timers + 1] = {
    time = os.time() + seconds,
    text = reason,
    owner = Trim(who or ""),
  }
end


function hms_to_sec(hh, mm, ss)
  local seconds = 0

  ss = tonumber(ss)
  mm = tonumber(mm)
  hh = tonumber(hh)

  if (ss) then
    seconds = ss
  end

  if (mm) then
    seconds = seconds + (mm * 60)
  end

  if (hh) then
    seconds = seconds + (hh * 60 * 60)
  end

  return seconds
end


function current_time_of_day_as_sec()
  local current_hh = tonumber(os.date("%H", os.time()))
  local current_mm = tonumber(os.date("%M", os.time()))
  local current_ss = tonumber(os.date("%S", os.time()))
  local current_seconds = (current_hh * 60 * 60) + (current_mm * 60) + current_ss

  return current_seconds
end


function show_newest_timer(seconds)
  ColourTell("silver", "black", os.date("%x %X", timers[#timers].time))
  Tell(" (")
  ColourTell("silver", "black", make_hh_mm_ss(seconds))
end



----------------
-- list timers
----------------

function list_timers()
  Note("-- meh_timers: list of countdown timers --")

  show_timers_header()

  local t = sort_timers()

  for i = 1, #t do
    for j = 1, #t[i] do
      local k = t[i][j]
      show_a_timer(timers[k])
    end
  end
end


function list_timers_matching(txt)
  txt = string.lower(Trim(txt))

  Note("-- meh_timers: list of countdown timers matching " .. txt .. " --")

  show_timers_header()

  local t = sort_timers()

  for i = 1, #t do
    for j = 1, #t[i] do
      local k = t[i][j]
      if (string.find(string.lower(timers[k].text), txt)) then
        show_a_timer(timers[k])
      end
    end
  end
end


function show_timers_header()
  Note("date/time          countdown    reason                      set by")
end


function sort_timers()
  local ttimes = {}
  local tindex = {}

  for i = 1, #timers do
    ttimes[#ttimes + 1] = timers[i].time

    if (not tindex[timers[i].time]) then
      tindex[timers[i].time] = {}
    end
    table.insert(tindex[timers[i].time], i)
  end

  table.sort(ttimes)

  local t = {}

  for i = 1, #ttimes do
    t[#t + 1] = tindex[ttimes[i]]
  end

  return t
end


function show_a_timer(timer)
  ColourTell("silver", "black", os.date("%x %X", timer.time))
  Tell("  ")

  ColourTell("silver", "black", make_hh_mm_ss(timer.time - os.time()))
  Tell("  ")

  local txt
  if (string.len(timer.text) > 26) then
    txt = string.sub(timer.text, 1, 26)
  elseif (timer.text == "") then
    txt = "-"
  else
    txt = timer.text
  end

  ColourTell("silver", "black", txt)
  Tell(string.rep(" ", 26 - string.len(txt)))
  Tell("  ")

  ColourNote("silver", "black", string.sub(timer.owner, 1, 20))
end


function make_hh_mm_ss(ss)
  local res, hh, mm

  mm = math.floor(ss / 60)
  ss = ss % 60
  if (ss < 10) then
    ss = "0" .. ss
  end

  hh = math.floor(mm / 60)
  if (hh < 10) then
    hh = "0" .. hh
  end

  mm = mm % 60
  if (mm < 10) then
    mm = "0" .. mm
  end

  res = hh .. "h " .. mm .. "m " .. ss .. "s"

  return res
end



----------------------
-- pop / fire timers
----------------------

function check_timers()
  local timer

  for i = #timers, 1, -1 do
    if (timers[i].time <= os.time()) then
      timer = table.remove(timers, i)
      show_alarm(timer)
    end
  end
end


function show_alarm(timer)
  -- show in main window
  Tell("*** ")
  ColourTell("white", "black", "(timer)")
  if (timer.text ~= "") then
    ColourTell("white", "black", " " .. timer.text)
  end
  Note(" ***")

  -- add to events world or mini
  add_to_events(timer.text)

  -- make noise
  if (sound_file) then
    play_sound(sound_file)
  end

  sapi_say(timer.text)
end



-----------
-- events
-----------

function add_to_events(txt)
  add_to_events_world(txt)
  add_to_events_mini(txt)
end


function add_to_events_world(txt)
  local world = GetWorld("events")

  if (world) then
    world:Note("")
    world:ColourTell("silver", "black", "[".. os.date("%H:%M:%S") .. "] ")
    world:Note(txt)
    world:Note("")
  end
end


function add_to_events_mini(txt)
  function add_style_to_events_mini(fgcol, bgcol, txt)
    CallPlugin("9ced43d0a7b4a60116794096", "add_to_mini", fgcol, bgcol, txt)
  end

  -- OnPluginListChanged() should keep 'use_events_mini' updated

  if (use_events_mini) then
    add_style_to_events_mini("silver", "black", "[".. os.date("%H:%M:%S") .. "] ")
    add_style_to_events_mini("white", "black", "(timer)")
    if (txt ~= "") then
      add_style_to_events_mini("white", "black", " " .. txt)
    end
    add_style_to_events_mini("silver", "black", "\r\n")
  end
end


function events_mini_installed()
  return is_plugin_present("events_mini", "9ced43d0a7b4a60116794096")
end



-----------------
-- play a sound
-----------------

function play_sound(sound_file)
  if (use_play_sounds) then
    local res = CallPlugin("4327c10cd9ae383bef04a7fc", "play_a_sound", sound_file)
  end
end


function play_sounds_present()
  return is_plugin_present("play_sounds", "4327c10cd9ae383bef04a7fc")
end



---------------
-- SAPI stuff
---------------

function sapi_say(text)
  if (use_sapi) then
    local res = CallPlugin("463242566069ebfd1b379ec1", "say", text)
  end
end


function sapi_plugin_present()
  return is_plugin_present("Sapi_speaker", "463242566069ebfd1b379ec1") or is_plugin_present("Text_To_Speech", "463242566069ebfd1b379ec1")
end



]]>

</script>

</muclient>
