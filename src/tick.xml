<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, December 01, 2011, 11:54 AM -->
<!-- MuClient version 4.73 -->

<!-- Plugin "tick" generated by Plugin Wizard -->

<muclient>

<plugin
   name="tick"
   author="Ruthgul"
   id="783cca60ac0d776ca859de57"
   language="Lua"
   purpose="countdown to next tick"
   save_state="y"
   date_written="2011-12-01 11:51:38"
   date_modified="2020-09-28 10:45:54"
   requires="4.71"
   version="1.0"
   >

<description trim="y">

<![CDATA[

.--------.
 | tick |
`--------'

It keeps track of game ticks, and lets you know when they're about to happen.

- If MushReader is NOT present, it will show a miniwindow with a countdown to next tick.

- If MushReader is detected (and play_sounds is present), it will play a short sound 3 seconds before a tick.


Syntax:

* tick sync  - (re-)synchronizes the tick

> if the miniwindow is on:

* tick bar   - toggle bar gauge mode on (on by default)
* tick circ  - toggle circular gauge mode
* tick ring  - toggle ring gauge mode
* tick num   - toggle numeric mode

* tick size [1|2]  - makes the miniwindow normal size (1) or double size (2) - default is 1

> if a screen reader is on:

* tick mute  - toggles SAPI announcements for ticks off / on


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Variables  -->

<variables>

  <variable name="char_name">[a-zA-Z0-9 \-\,\.\']+</variable>

  <variable name="warning_freq">1</variable>

</variables>



<!--  Aliases  -->

<aliases>

  <alias
   enabled="y"
   match="^tick sync(| (?P&lt;syncat&gt;[0-9]+))$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>resync_tick("%&lt;syncat&gt;")
</send>
  </alias>


<!-- SAPI -->

  <alias
   enabled="y"
   match="^tick mute$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>toggle_mute()
</send>
  </alias>


<!-- mini-window -->

  <alias
   enabled="y"
   match="^tick (?P&lt;mode&gt;(bar|circ(|le)|ring|num))$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (tick_started) then
  change_mode("%&lt;mode&gt;")
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^tick size (?P&lt;size&gt;(1|2))$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (tick_started) then
  change_size("%&lt;size&gt;")
end
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^tick(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Triggers  -->

<triggers>

  <trigger
   enabled="y"
   name="sync"
   keep_evaluating="y"
   expand_variables="y"
   match="^(A sudden\, strong gust of wind knocks you to the ground\!|The current pulls you along to the (.+)\.\.\.|A sudden torrent of lava sweeps you the (.+)\.|(You are|(@!char_name) is) buffeted to the (.+) by crosswinds\!|You shiver and suffer from the poison burning within\.|(@!char_name) shivers and suffers\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>tick_happened("%0")
</send>
  </trigger>

</triggers>



<!--  Timers  -->

<timers>

  <timer
   enabled="y"
   second="0.50"
   offset_second="0.00"
   active_closed="y"
   send_to="12"
  >
  <send>check_timer()
</send>
  </timer>

</timers>



<!--  Script  -->

<script>

<![CDATA[

debug = false
require "movewindow"
require "gauge"
require "wait"


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  wait.make(function()
    Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
    ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
    Note(" to see info about this plugin --")

    -- give other plugins some time to initialize
    wait.time(3)
    detect_plugins()

    -- only initialize / show the miniwindow if we don't detect MushReader
    if (not reader_present) then
      mode = GetVariable("mode") or "bar" -- default mode is gauge

      win_size = tonumber(GetVariable("win_size") or 1)

      tick_start()
    end

    last_noise = nil
    resync_tick()
  end)
end


function OnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID(), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo(GetPluginID(), 14)) .. ")")
end


function OnPluginClose()
  if (tick_started) then
    movewindow.save_state(itick)
    WindowShow(itick, false)  -- hide window on removal
  end
end


function OnPluginDisable()
  if (tick_started) then
    WindowShow(itick, false)  -- hide window on disable
  end
end


function OnPluginSaveState()
  if (tick_started) then
    movewindow.save_state(itick)
  end
end


function OnPluginListChanged()
  detect_plugins()
end


function detect_plugins()
  play_sounds_present = play_sounds_plugin_present()
  reader_present = reader_plugin_present()
end


function is_plugin_present(name, id)
  local res = false

  local plugin_name = GetPluginInfo(id, 1)

  if (plugin_name == name) then
    -- is it enabled?
    if (GetPluginInfo(id, 17)) then
      res = true
    end
  end

  return res
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/tick.xml",
  }
  return (table.concat(t, ";"))
end


function plugin_update_aux_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/res/tick.mp3,MUSH/sounds",
  }
  return (table.concat(t, ";"))
end



-----------
-- toggle
-----------

function change_mode(mymode)
  if (mymode == "circle") then
    mymode = "circ"
  end

  if (mode ~= mymode) then
    mode = mymode
    SetVariable("mode", mode)
    SaveState()
    tick_start()
  end
end


function change_size(size)
  win_size = tonumber(size)
  SetVariable("win_size", win_size)
  SaveState()
  tick_start()
end



---------------
-- tick stuff
---------------

function resync_tick(syncat)
  last_sec_done = 0

  if (not syncat) or (syncat == "") then
    sync_at = nil
    last_sec_done = 0
--    EnableTrigger("sync", true)

    if (tick_started) then
      show_tick(-1)
    end

    Note("-- tick: waiting for some of the next things to happen, to synchronize: poison, wind, crosswinds, current --")

  else
    syncat = tonumber(syncat)

    if (syncat >= 1) and (syncat <= 15) then
      sync_at = tonumber(syncat)
    end
  end
end


-- here every 500 ms

function check_timer()
  if (sync_at) then
    if (os.time() > last_sec_done) then -- we haven't processed this second
      last_sec_done = os.time()

      -- RL seconds
      local sec = tonumber(os.date("%S", os.time()))

      -- tick seconds (0 to 14)
      sec = sec - sync_at
      if (sec < 0) then
        sec = sec + 15
      end
      sec = math.fmod(sec, 15)

      -- tick seconds (countdown)
      tick_seconds = 15 - sec

      if (debug) and (tick_seconds == 15) then
        Note("[" .. os.date("%H:%M:%S") .. "] -- tick! --")
--        Note("RL sec: " .. os.date("%S", os.time()) .. " - sec: " .. sec .. " - tick_seconds: " .. tick_seconds)
      end

      if (tick_started) then
        show_tick(tick_seconds)

      elseif (not tick_mute) then
        if (tick_seconds == 3) then
          if (tick_seconds ~= last_noise) then
            make_noise()
            last_noise = 3
          end

        else
          last_noise = nil
        end
      end
    end
  end

  return 0
end


-- here on tick

function tick_happened(line)
--  EnableTrigger("sync", false)

  local sec = tonumber(os.date("%S", os.time())) -- RL seconds
  if (debug) then
    Note("-- tick: happened at " .. sec .. "s RL time --")
  end

  local new_sync_at

  sec = math.fmod(sec, 15) -- tick seconds (1 to 15)
  if (sec > 0) then
    new_sync_at = sec
  else
    new_sync_at = 15
  end

  if (not sync_at) then -- not sync'd => sync
    sync_at = new_sync_at
    Note("-- tick: synchronized at " .. sync_at .. "s --")

  else -- already sync'd
    if (math.abs(new_sync_at - sync_at) > 1) then -- probably unsync'd
      local warn_freq = tonumber(GetVariable("warning_freq"))

      if (os.time() >= ((unsync_warned or 0) + (warn_freq * 60))) then
      -- warn_freq min have passed since the last warning
        unsync_warned = os.time()
        Note("-- tick warning: possibly unsynchronized --")
        Note("(if you're not lagging and this persists, type 'tick sync' to resync)")
      end
    end
  end

  if (debug) then
    AppendToNotepad("tick", "\r\n[" .. os.date("%H:%M:%S") .. " tick] " .. line .. "\r\n")
  end
end



-----------------
-- window stuff
-----------------

bgcol = ColourNameToRGB("black")
bordercol = "2434341"

font = "Lucida Console"  -- monospaced font
fontsize = 9
fontcol = ColourNameToRGB("whitesmoke")

gauges_height = 19  -- bar gauges
gauges_spacing = 2

gaugecol = "10975553"  -- fill color for gauges

cgauge_blank_space = 6  -- blank space around circular gauge


function pick_mode_stuff(mode)
  if (mode == "bar") or (mode == "num") then
    width = 125
    height = 31

  else
    width = 80
    height = 80
  end
end


function tick_start()
  itick = "itick_" .. GetPluginID()

  WindowCreate(itick, 0, 0, 0, 0, 0, 0, 0)

  pick_mode_stuff(mode)

  WindowFont(itick, "ftick", font, fontsize * win_size, false, false, false, false)
  txtwidth = WindowTextWidth(itick, "ftick", "-- TICK! --", true)
  font_height = WindowFontInfo(itick, "ftick", 1)

  windowinfo = movewindow.install(itick, miniwin.pos_top_center)

  WindowShow(itick, false)

  WindowCreate(itick, windowinfo.window_left, windowinfo.window_top, width * win_size, height * win_size, windowinfo.window_mode, windowinfo.window_flags, bgcol)

  -- let them move it around
  movewindow.add_drag_handler(itick, 0, 0, width * win_size, height * win_size, 10)

  -- draw 3D box
  draw_3d_box(itick, 2, 2, (width - 4) * win_size, (height - 4) * win_size)

  tick_started = true

  if (not sync_at) then
    show_tick(-1) -- unsync'd
  end

  WindowShow(itick, true)
end


function tick_show()
  if (tick_started) then
    WindowShow(itick, true)
  end
end


function tick_hide()
  if (tick_started) then
    WindowShow(itick, false)
  end
end


function show_tick(num)
  num = tonumber(num)

  if (mode == "bar") then
    gauge(itick, "to next tick", num, 15, 7 * win_size, 6 * win_size, (width - 13) * win_size, gauges_height * win_size, gaugecol, bgcol, 14, bgcol, bordercol, bgcol)

    if (num == -1) or (num == 15) then
      show_text_n_shadow(tick_to_text(num), 26 * win_size, 10 * win_size)
    end

  elseif (mode == "circ") then
    circular_gauge(itick, num, 15, cgauge_blank_space * win_size, cgauge_blank_space * win_size, (width - cgauge_blank_space) * win_size, (height - cgauge_blank_space) * win_size, gaugecol, bgcol, 15, bordercol, true)

    if (num == -1) or (num == 15) then
      show_text_n_shadow(tick_to_text(num), 6 * win_size + ((width - cgauge_blank_space) * win_size - txtwidth) / 2, 4 * win_size + ((height - cgauge_blank_space) * win_size - font_height) / 2)
    end

  elseif (mode == "ring") then
    ring_gauge(itick, num, 15, cgauge_blank_space * win_size, cgauge_blank_space * win_size, (width - cgauge_blank_space) * win_size, (height - cgauge_blank_space) * win_size, 50, gaugecol, bgcol, 15, bordercol, bgcol, true)

    if (num == -1) or (num == 15) then
      show_text_n_shadow(tick_to_text(num), 6 * win_size + ((width - cgauge_blank_space) * win_size - txtwidth) / 2, 4 * win_size + ((height - cgauge_blank_space) * win_size - font_height) / 2)
    end

  else -- mode is num
    draw_text_box(itick, "ftick", 25 * win_size, 10 * win_size, tick_to_text(num), false, fontcol, bgcol, bgcol)
  end
  WindowShow(itick, true)
end


function tick_to_text(num)
  local txt
  if (num == -1) then
    txt = "  sync...  "

  elseif (num == 15) then
    txt = "   TICK!   "

  elseif (num > 9) then
    txt = num .. "s to tick"

  elseif (num > 0) then
    txt = " " .. num .. "s to tick"
  end

  return txt
end


function show_text_n_shadow(txt, x, y)
  WindowText(itick, "ftick", txt, x, y + 1, 0, 0, bgcol, false) -- shadow
  WindowText(itick, "ftick", txt, x, y, 0, 0, fontcol, false) -- text
end



--------------------------
-- circular gauges stuff
--------------------------

-- this code implements:
-- * circular sectors using degrees
-- * circular gauges (full circle and ring modes)


nofill_color = -1  -- equals no fill, for sectors


function sector(win,                        -- miniwindow ID to draw in
                left, top, right, bottom,   -- where to put it inside the window
                border_color,               -- colour for border,
                fill_color,                 -- colour for fill (-1 for no fill)
                start_angle, end_angle)     -- start and end angles, in degrees,
                                            -- counting from y+, clockwise

  local radius = (right - left) / 2

  local start_x, start_y, end_x, end_y

  -- making it start at y+ and "grow" clockwise
  start_angle = start_angle + 180
  end_angle = end_angle + 180

  -- x, y from the center of the circle
  start_x = -radius * math.sin(math.rad(start_angle))
  start_y = radius * math.cos(math.rad(start_angle))

  end_x = -radius * math.sin(math.rad(end_angle))
  end_y = radius * math.cos(math.rad(end_angle))

  -- center x, y relative to left, top
  center_x = left + radius
  center_y = top + radius

  -- x, y relative to left, top
  start_x = center_x + start_x
  start_y = center_y + start_y

  end_x = center_x + end_x
  end_y = center_y + end_y

  local brush = miniwin.brush_solid
  if (fill_color == -1) then -- no fill
    brush = miniwin.brush_null
  end

  WindowCircleOp(win, miniwin.circle_pie,   -- pie
        left, top, right, bottom,           -- where to put it inside the window
        border_color, miniwin.pen_solid, 1, -- border, solid pen, width 1
        fill_color, brush,                  -- fill, solid brush
        end_x, end_y,                       -- x, y of the ending point
        start_x, start_y)                   -- x, y of the starting point
end


function circular_gauge(win,                      -- miniwindow ID to draw in
                        current, max,             -- current and max value (eg, 50, 100)
                        left, top, right, bottom, -- where to put it inside the window
                        fill_color, unfill_color, -- color for fill and unfilled parts
                        ticks,                    -- # of "ticks" (ie sectors) to draw
                        border_color,             -- color for the border of the circle
                        clockwise)                -- will it "unfill" clockwise
                                                  -- or counterclockwise?)

  local start_angle, end_angle

  start_angle = 0
  end_angle = current * 360 / max

  if (clockwise) then
    start_angle = 360 - start_angle
    end_angle = 360 - end_angle

    start_angle, end_angle = end_angle, start_angle
  end

  -- draw unfilled sector
  if (current < max) then
    sector(win, left, top, right, bottom, border_color, unfill_color, end_angle, 360)
  end

  -- draw filled sector
  if (current > 0) then
    sector(win, left, top, right, bottom, border_color, fill_color, start_angle, end_angle)
  end

  -- draw "tick" sectors
  if (ticks > 1) then
    -- "span" of a sector tick
    local tick_angle
    tick_angle = 360 / ticks

    for i = 1, ticks do
      start_angle = tick_angle * (i - 1)
      end_angle = start_angle + tick_angle

      sector(win, left, top, right, bottom, border_color, nofill_color, start_angle, end_angle)
    end
  end
end


function ring_gauge(win,                      -- miniwindow ID to draw in
                    current, max,             -- current and max value (eg, 50, 100)
                    left, top, right, bottom, -- where to put it inside the window
                    ring_width,               -- ring width as a percentage (eg, 50)
                    fill_color, unfill_color, -- color for fill and unfilled parts
                    ticks,                    -- # of "ticks" (ie sectors) to draw
                    border_color, bg_color,   -- colors for border and background
                    clockwise)                -- will it "unfill" clockwise
                                              -- or counterclockwise?)

  -- show circular gauge as usual
  circular_gauge(win, current, max,
                 left, top, right, bottom,
                 fill_color, unfill_color,
                 ticks, border_color, clockwise)

  -- cover the center with a circle filled with bg_color
  local outer_diameter = right - left
  local center_diameter = outer_diameter * (100 - ring_width) / 100
  local center_padding = (outer_diameter - center_diameter) / 2

  WindowCircleOp(win, miniwin.circle_ellipse,         -- circle
                 left + center_padding, top + center_padding, right - center_padding, bottom - center_padding,             -- left, top, right, bottom
                 border_color, miniwin.pen_solid, 1,  -- border, solid pen, width 1
                 bg_color, miniwin.brush_solid)       -- fill, solid brush
end



----------
-- sound
----------

function toggle_mute()
  tick_mute = tick_mute or false

  tick_mute = not tick_mute

  if (tick_mute) then
    Note("-- tick is now muted --")

  else
    Note("-- tick is no longer muted --")
  end
end


function make_noise()
  -- if play_sounds is installed + 'ping.mp3' file exists, play it

  if (reader_present) and (play_sounds_present) then
    Execute("play a sound tick.mp3")
  end
end


function play_sounds_plugin_present()
  return is_plugin_present("play_sounds", "4327c10cd9ae383bef04a7fc")
end


function reader_plugin_present()
  return is_plugin_present("MushReader", "925cdd0331023d9f0b8f05a7")
end


function is_plugin_present(name, id)
  local res = false

  local plugin_name = GetPluginInfo(id, 1)

  if (plugin_name == name) then
    -- is it enabled?
    if (GetPluginInfo(id, 17)) then
      res = true
    end
  end

  return res
end


]]>

</script>

</muclient>
