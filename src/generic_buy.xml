<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, April 26, 2012, 2:35 PM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "generic_buy" generated by Plugin Wizard -->

<muclient>

<plugin
   name="generic_buy"
   author="Ruthgul"
   id="a326b480b3f02b3ff6d58e7d"
   language="Lua"
   purpose="automates buying items in bulk"
   date_written="2012-04-26 14:33:06"
   date_modified="2014-08-04 05:53:22"
   requires="4.71"
   version="1.0"
   >

<description trim="y">

<![CDATA[

.---------------.
 | generic_buy |
`---------------'

Syntax:

* bfill <item> <container>  - will buy the specified item to fill the container (eg: bfill usicur 2.satchel).

* blistfill <items> <container>  - will buy equal numbers of the specified items, to fill the container. Use spaces to separate the items you want to buy (eg: blistfill verbena centaures rosa salvia eliotropia cloud).

* bnum <amount> <item> <container>  - will buy the specified amount of the item and put it in the container (eg: bnum 50 focusing trunk). If amount > free capacity, it will fill the container instead.

* bstop  - will stop buying (if auto-stop conditions fail)


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

<!--

add when finished:

* btonum <amount> <item> <container> - will buy an item to reach the desired amount, and put it in the container (eg: bnum 50 focusing trunk). If there's already items of that type in the container, it will buy amount - have. If have > amount, then it will descard the excedent. If (amount - have) > free capacity, it will fill the container instead.

-->


</description>

</plugin>



<!--  Variables  -->

<variables>

  <variable name="char_name">[a-zA-Z0-9 \-\,\.\']+</variable>

</variables>



<!--  Triggers  -->

<triggers>

<!-- container capacity -->

  <trigger
   group="capacity"
   keep_evaluating="y"
   match="^\[C\]ontinue \[R\]edraw \[B\]ack \[E\]xit\: $"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>auto_cont()
</send>
  </trigger>

  <trigger
   group="capacity"
   keep_evaluating="y"
   match="^A total of (?P&lt;have&gt;.+) item(|s) weighing (.+) st(|s)\, (.+) pb(|s)\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>get_used_slots("%&lt;have&gt;")
</send>
  </trigger>

  <trigger
   group="capacity"
   keep_evaluating="y"
   match="^[ ]+Nothing\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>get_used_slots(0)
</send>
  </trigger>

  <trigger
   group="capacity"
   keep_evaluating="y"
   match="^Capacity\: (?P&lt;max&gt;.+) item(|s)\. Maximum weight\: (.+) st(|s)\, (.+) pb(|s)\. Flags\: (.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>get_total_slots("%&lt;max&gt;")
</send>
  </trigger>


<!-- buy -->

  <trigger
   name="autostop"
   keep_evaluating="y"
   expand_variables="y"
   match="^(((@!char_name) tells you \'(I\'m sorry\, but I do not sell that item\.|Sorry\, but I am not open for business right now\. Come back between the hours of (.+)\.|Sorry\, but I only sell quest items\. Use the QUEST command\.|You do not have enough gold(| or credits) to make that purchase\.|Your hands are full\.)\')|There isn\'t a shopkeeper present\.|You do not see that here\.|That\'s not something in which you can look\.|(.+) is closed\.|You may only place items of type \'(.+)\' in (.+)\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>auto_stop()
</send>
  </trigger>

</triggers>



<!--  Aliases  -->

<aliases>

<!-- buy -->

  <alias
   enabled="y"
   group="script-buy"
   match="^bfill[ ]+(?P&lt;item&gt;.+)[ ]+(?P&lt;cont&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>buy_put(-1, "%&lt;item&gt;", "%&lt;cont&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   group="script-buy"
   match="^bnum[ ]+(?P&lt;num&gt;[0-9]+)[ ]+(?P&lt;item&gt;.+)[ ]+(?P&lt;cont&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>buy_put("%&lt;num&gt;", "%&lt;item&gt;", "%&lt;cont&gt;")
</send>
  </alias>

  <alias
   enabled="n"
   group="script-buy"
   match="^btonum[ ]+(?P&lt;num&gt;[0-9]+)[ ]+(?P&lt;item&gt;.+)[ ]+(?P&lt;cont&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>buy_to_num_n_put("%&lt;num&gt;", "%&lt;item&gt;", "%&lt;cont&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   group="script-buy"
   match="^blistfill[ ]+(?P&lt;wildcards&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>buy_list("%&lt;wildcards&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   group="script-buy"
   match="^bstop$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>auto_stop()
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^generic_buy(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Scripts  -->

<script>

<![CDATA[

require "wait"


-----------
-- plugin
-----------

function OnPluginInstall()
  Tell("-- " .. GetPluginInfo(GetPluginID (), 1) .. ": type ")
  ColourTell("silver", "black", GetPluginInfo(GetPluginID (), 1) .. " help")
  Note(" to see info about this plugin --")

  stop_buying = false
  buying = false
  buying_loop = false
end


function OnHelp ()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID (), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo (GetPluginID(), 14)) .. ")")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/generic_buy.xml",
  }
  return (table.concat(t, ";"))
end



------------
-- general
------------

function auto_cont()
  SendNoEcho("C")
end


-------------
-- capacity
-------------

function get_used_slots (num)
  used_slots = tonumber(num)
end


function get_total_slots(num)
  total_slots = tonumber(num)
end


--------
-- buy
--------

function auto_stop()
  stop_buying = true
end


local function single_buy_put(num, item, container)
  -- it will buy num items, and put them in the container
  --    (once)
  Send("shop buy " .. num .. " " .. item)
  Send("put all." .. item .. " " .. container)
end


local function repeat_buy_put(num, item, container)
  -- requires: num <= available capacity in the container
  -- it will buy num items, and put them in the container
  --    (repeating buy/put as many times as necessary)
  buying_loop = true

  wait.make (function ()
    local imax = math.modf (num / 20)  -- how many times will we need to buy 20 items
    local frem = math.fmod(num, 20)    -- the remainder, to reach num items

    local i = 1
    stop_buying = false
    while ((not stop_buying) and (i <= imax)) do
      single_buy_put(20, item, container)
      wait.regexp("^(You put (.+) in (.+)\\.|You do not see an item called (.+)\\.|You see no (.+) here\\.)$",-1,trigger_flag.KeepEvaluating)
      wait.time (.3)
      i = i + 1
    end

    if ((not stop_buying) and (frem > 0)) then
      single_buy_put(frem, item, container)
    end
  end)

  buying_loop = false
end


function buy_put(amount, item, container)
  -- when amount == -1, or amount > container's free capacity,
  --    it will buy items until the container is full
  -- otherwise, it will buy amount items
  -- in all cases, it will place the items in the container

  wait.make (function ()
    if (not buying) then
      buying = true

      num = tonumber(amount)
      if (num ~= nil) then -- amount is a valid number
        total_slots = nil
        used_slots = nil
        EnableTriggerGroup("capacity", true)
        Send("look " .. container)
        wait.regexp("^(.*?)\\<(.+)hp (.+)sp (.+)st\\> $",-1,trigger_flag.KeepEvaluating)
        wait.time (.3)
        EnableTriggerGroup("capacity", false)

        if (total_slots) and (used_slots) then
          local free_slots = total_slots - used_slots

          if (num == -1) then  -- our code to buy items until the container is full
            repeat_buy_put(free_slots, item, container)

          elseif (num <= free_slots) then
            repeat_buy_put(num, item, container)

          elseif (free_slots > 0) then
            Note("-- generic_buy - warning: the number requested exceeds the free capacity of the container --")
            Note("(buying " .. free_slots .. " items instead")
            repeat_buy_put(free_slots, item, container)

          elseif (free_slots == 0) then
            Note("-- generic_buy - error: the container is full! --")
          end

        else
          Note("-- generic_buy - error: couldn't retrieve the container's capacity / free slots --")
        end

      else -- amount is not a valid number
        Note("-- generic_buy - error: " .. amount .. "is not a valid number! --")
      end

      buying = false

    else
      Note("-- generic_buy - error: already buying something! --")
    end
  end)
end


function buy_list(wildcards)
  -- requires wildcards = list of items separated by spaces, container at the end
  -- it will check the container's free capacity,
  -- and buy equal quantities of the specified items,
  -- until the container is near-full

  wait.make (function ()
    if (not buying) then
      buying = true

      local titems = utils.split(wildcards, " ") -- list of items, as a table
      local container = titems[#titems] -- last wildcard is container
      total_slots = nil
      used_slots = nil

      EnableTriggerGroup("capacity", true)
      Send("look " .. container)
      wait.regexp("^(.*?)\\<(.+)hp (.+)sp (.+)st\\> $",-1,trigger_flag.KeepEvaluating)
      wait.time(.3)
      EnableTriggerGroup("capacity", false)

      if (total_slots) and (used_slots) then
        local free_slots = total_slots - used_slots
  --      Note("free slots: " .. free_slots)

        local numitems = #titems - 1
        if (free_slots >= numitems) then -- enough free slots in the container to buy at least 1 of each item
          local num_each = math.modf (free_slots / numitems) -- how many to buy of each item
  --        Note("will buy: " .. num_each .. " of each item")

          local i = 1
          stop_buying = false
          while ((not stop_buying) and (i <= numitems)) do
            repeat_buy_put(num_each, titems[i], container)
            repeat
              wait.time(.5)
            until (not buying_loop) or (stop_buying)
            i = i + 1
          end

        else
          Note("-- generic_buy - error: not enough free space in the container to buy at least 1 of each specified item! --")
        end

      else
        Note("-- generic_buy - error: couldn't retrieve the container's capacity / free slots --")
      end

      buying = false

    else
      Note("-- generic_buy - error: already buying something! --")
    end
  end)
end


function buy_to_num_n_put(amount, item, container)
  -- tba
end


]]>

</script>

</muclient>
