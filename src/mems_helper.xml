<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, November 08, 2013, 8:34 AM -->
<!-- MuClient version 4.90 -->

<!-- Plugin "mems_helper" generated by Plugin Wizard -->

<muclient>

<plugin
   name="mems_helper"
   author="Ruthgul"
   id="3a006258a11ad009439f9dd9"
   language="Lua"
   purpose="keeps track of scribed spells and helps mem them"
   save_state="y"
   date_written="2013-11-08 08:33:43"
   date_modified="2020-09-28 09:12:34"
   requires="4.71"
   version="1.0"
   >

<description trim="y">

<![CDATA[

.---------------.
 | mems_helper |
`---------------'

- Keeps a database of spellbooks and scribed spells.
- Lets you choose which spells you want to memorize (default list + themed sets.)
- Builds your sequence of memorization commands, based on stored data.
- Calculates and shows the total complexity of memorized spells.


** REQUIRES **

- sequencer (plugin id="7daf1d7890d9db73d74a8188") must be installed and enabled.


Syntax:

> Spellbooks detection:

* detect all spellbooks <container>  - gets all spellbooks from the container, and detects them - it REQUIRES you to be able to carry all the spellbooks in that container; use /detect by type spellbooks.../ if you have low strength

* detect by type spellbooks <container>  - gets all spellbooks from the container, and detects them - it gets them by spellbook type, in sequence, so it can be used instead of /detect all spellbooks.../ if you have low strength, but it's slower

> Spellbooks purge:

* purge spellbooks [<container>]  - deletes all database info for spellbooks (if <container> is specified, it will only delete spellbooks stored in that container - otherwise, it will delete all)

> Spellbooks queries:

* list spellbooks  - shows a list of all detected spellbooks + their scribed spells

> Spellbooks locate & store:

* locate spellbook <spell_name>  - finds the spellbook that has the spell scribed, gets all spellbooks of that type from their container, and holds the spellbook

* store spellbooks  - removes and puts all spellbooks in your inventory in the last container you used (via locate spellbook...)


> Add / delete / list spells to memorize:

* add mem <spell_name>  - adds a spell to the default list you want to memorize
* add mem set:<set_name> spell:<spell_name>  - adds a spell to a set

* del mem <spell_name>  - removes a spell from the default list you want to memorize
* del mem set:<set_name> spell:<spell_name>  - removes a spell from a set

* list mems  - shows the default list of spells you want to memorize
* list mems set:<set_name>  - shows the list of spells in a set

* list sets  - shows your list of memorization sets


> Memorize / purge spells:

* memorize spells  - sequences the commands to make you purge all mems and memorize your default list of spells

* memorize spells set:<set_name>  - sequences the commands to make you memorize the spells in a set (it DOESN'T purge)
* purge spells set:<set_name>  - sequences the commands to make you purge the spells in a set from your memory


> Memorization complexity calculation:

* mem calc complexity  - shows the total complexity of your memorized spells


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Aliases  -->

<aliases>

<!-- spellbooks detection -->

  <alias
   enabled="y"
   match="^detect[ ]+all[ ]+spellbooks[ ]+(?P&lt;container&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  get_and_auto_detect_spellbooks("%&lt;container&gt;", "all")
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^detect[ ]+by[ ]+type[ ]+spellbooks[ ]+(?P&lt;container&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  get_and_auto_detect_spellbooks("%&lt;container&gt;", "by type")
else
  plugin_not_initialized()
end
</send>
  </alias>


<!-- spellbooks purge -->

  <alias
   enabled="y"
   match="^purge[ ]+spellbooks(|[ ]+(?P&lt;container&gt;.+))$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  purge_spellbooks("%&lt;container&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>


<!-- spellbooks queries -->

  <alias
   enabled="y"
   match="^list[ ]+spellbooks$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  list_all_spellbooks()
else
  plugin_not_initialized()
end
</send>
  </alias>


<!-- spellbooks locate & store -->

  <alias
   enabled="y"
   match="^locate[ ]+spellbook[ ]+(?P&lt;spell&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  locate_spellbooks("%&lt;spell&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^store[ ]+spellbooks$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  store_spellbooks()
else
  plugin_not_initialized()
end
</send>
  </alias>


<!-- add / delete spells to memorize -->

  <alias
   enabled="y"
   match="^add[ ]+mem[ ]+(?P&lt;spell&gt;[a-zA-Z ]+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  add_mem("%&lt;spell&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^add[ ]+mem[ ]+set\:(?P&lt;set&gt;[a-zA-Z\_ ]+)[ ]+spell\:(?P&lt;spell&gt;[a-zA-Z ]+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  add_mem_to_set("%&lt;set&gt;", "%&lt;spell&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>


  <alias
   enabled="y"
   match="^del[ ]+mem[ ]+(?P&lt;spell&gt;[a-zA-Z ]+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  del_mem("%&lt;spell&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^del[ ]+mem[ ]+set\:(?P&lt;set&gt;[a-zA-Z\_ ]+)[ ]+spell\:(?P&lt;spell&gt;[a-zA-Z ]+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  del_mem_from_set("%&lt;set&gt;", "%&lt;spell&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>


  <alias
   enabled="y"
   match="^list[ ]+mems$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  list_mems()
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^list[ ]+mems[ ]+set\:(?P&lt;set&gt;[a-zA-Z\_ ]+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  list_mems_in_set("%&lt;set&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^list[ ]+sets$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  list_mems_sets()
else
  plugin_not_initialized()
end
</send>
  </alias>


<!-- memorize / purge spells -->

  <alias
   enabled="y"
   match="^memorize[ ]+spells$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  memorize()
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^memorize[ ]+spells[ ]+set\:(?P&lt;set&gt;[a-zA-Z\_ ]+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  memorize_set("%&lt;set&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>

  <alias
   enabled="y"
   match="^purge[ ]+spells[ ]+set\:(?P&lt;set&gt;[a-zA-Z\_ ]+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  purge_set("%&lt;set&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>


<!-- memorization complexity calculation -->

  <alias
   enabled="y"
   match="^mem[ ]+calc[ ]+complexity$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>calc_mem_cmplx()
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^mems\_helper(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Triggers  -->

<triggers>

<!-- on first prompt -->

  <trigger
   enabled="y"
   name="first_prompt"
   keep_evaluating="y"
   match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)|\&gt;) $"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>on_first_prompt()
</send>
  </trigger>


<!-- detect if exists -->

  <trigger
   name="detect_container"
   keep_evaluating="y"
   match="^(You see no (.+) here\.|(.+)\: That\'s not a container\.|(.+) is closed\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>no_such_container()
</send>
  </trigger>

  <trigger
   name="detect_spellbook_type"
   keep_evaluating="y"
   match="^You see nothing like that in (.+)\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>no_such_spellbook_type()
</send>
  </trigger>

  <trigger
   name="detect_spellbook"
   keep_evaluating="y"
   match="^(You do not see that here\.|You only see [0-9]+ \'(.+)\' here\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>no_such_spellbook()
</send>
  </trigger>


<!-- detect spells / spellbooks -->

  <trigger
   group="detect_spells"
   keep_evaluating="y"
   match="^Item \'(?P&lt;name&gt;.+)\' is type spellbook\, alignment (.+)\, made of (.+) \(in \((.+)\) condition\)\,\[Study\]$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>spellbook_detected("%&lt;name&gt;")
</send>
  </trigger>

  <trigger
   group="detect_spells"
   keep_evaluating="y"
   match="^Level [0-9]+ item \'(?P&lt;name&gt;.+)\' is type spellbook\, with keywords \'(.+)\'\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>spellbook_detected("%&lt;name&gt;")
</send>
  </trigger>

  <trigger
   keep_evaluating="y"
   match="^This spellbook has no spells scribed in it\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>spells_detected("")
</send>
  </trigger>

  <trigger
   group="detect_spells"
   keep_evaluating="y"
   match="^Contains the spell(|s)\: (?P&lt;spells&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>spells_detected("%&lt;spells&gt;")
</send>
  </trigger>


<!-- mem calc - detect complexities -->

  <trigger
   group="detect_cmplx"
   keep_evaluating="y"
   match="^\[C\]ontinue \[R\]edraw \[B\]ack \[E\]xit\: $"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>auto_cont()
</send>
  </trigger>

  <trigger
   group="detect_cmplx"
   expand_variables="y"
   keep_evaluating="y"
   match="^[ ]+[0-9]+[ ]+(?P&lt;spell&gt;[a-z](.+)[a-z])[ ]+(ABJ|ALT|CHA|CON|DIV|ELE|ENC|EVO|FUN|ILL|INV|NEC|SUM|THO)[ ]+[0-9]+[ ]+(?P&lt;cmplx&gt;[0-9]+)\%[ ]+[0-9]+\%(.*?)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>process_spell("%&lt;spell&gt;", "%&lt;cmplx&gt;")
</send>
  </trigger>

  <trigger
   group="detect_cmplx"
   keep_evaluating="y"
   match="^You have \[(.+)\] practice sessions\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>end_of_spells_list()
</send>
  </trigger>


<!-- mem calc - detect memorized spells -->

  <trigger
   group="detect_mems"
   keep_evaluating="y"
   match="^[ ]*(?P&lt;spell1&gt;[a-z ]+) \(expires\:[ ]+ [0-9]+ m\)[ ]+(?P&lt;spell2&gt;[a-z ]+) \(expires\:[ ]+ [0-9]+ m\)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>memmed_spells_line("%&lt;spell1&gt;", "%&lt;spell2&gt;")
</send>
  </trigger>

  <trigger
   group="detect_mems"
   keep_evaluating="y"
   match="^[ ]*(?P&lt;spell&gt;[a-z ]+) \(expires\:[ ]+[0-9]+ m\)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>memmed_spells_line("%&lt;spell&gt;", "")
</send>
  </trigger>

  <trigger
   group="detect_mems"
   keep_evaluating="y"
   match="^(A total of [0-9]+ spell(|s)\.|You don\'t currently have any spells memorized\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>calc_mems()
</send>
  </trigger>

</triggers>



<!--  Scripts  -->

<script>

<![CDATA[

require "serialize"
require "wait"


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  wait.make(function()
    Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
    ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
    Note(" to see info about this plugin --")

    -- open database on disk
    db = assert(sqlite3.open(GetInfo(66) .. "spellbooks.db"))

    -- create database structure if necessary
    create_tables()

    EnableTrigger("first_prompt", true)
    name = nil

    -- first_run is checked to always run make_mems_sequence the first time,
    -- to deal with savestate file corruption
    first_run = true

    -- give the plugins time to initialize
    wait.time(3)
    detect_plugins()
  end)
end


function OnPluginConnect()
  EnableTrigger("first_prompt", true)
  name = nil
end



function OnPluginListChanged()
  detect_plugins()
end


function detect_plugins()
  sequencer_present = sequencer_plugin_present()
end


function is_plugin_present(name, id)
  local res = false

  local plugin_name = GetPluginInfo(id, 1)

  if (plugin_name == name) then
    -- is it enabled?
    if (GetPluginInfo(id, 17)) then
      res = true
    end
  end

  return res
end


function OnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID(), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo(GetPluginID(), 14)) .. ")")
end


function plugin_not_initialized()
  Note("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": plugin initialization unfinished --")
  Note("please wait 5 seconds and try again")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/mems_helper.xml",
  }
  return (table.concat(t, ";"))
end



------------------
-- general stuff
------------------

function on_first_prompt()
  EnableTrigger("first_prompt", false)

  do_get_name()
end


function OnPluginBroadcast(msg, id, pname, text)
  if (id =="97784abf5f30629a0d7e7307")
  and (pname == "global_vars") then -- global_vars
    if (msg == 1) and (text == "name") then
      -- name broadcasted
      do_get_name()
    end
  end
end


function do_get_name()
  name = get_global_var("name")
end


function get_global_var(name)
  local res, val

  res, val = CallPlugin("97784abf5f30629a0d7e7307", "get_global_var", name)

  if (res ~= 0) then
    val = nil
  end

  return val
end


function quote_container(container)
  local quote, quoted_container

  quote = pick_quote_char(container)
  quoted_container = quote .. container .. quote

  return quoted_container
end


function quote_spellbook(num, type)
  local quote, quoted_spellbook

  quote = pick_quote_char(type)

  if (num == "all") then
  -- if it's 4.an orange spellbook, we want to be all.'an orange spellbook'
    quoted_spellbook = "all." .. quote .. type .. quote

  elseif(tonumber(num)) then
  -- if it's 4.an orange spellbook, we want to be '4.an orange spellbook'
    quoted_spellbook = quote .. num .. "." .. type .. quote

  else
  -- if it's just an orange spellbook, we want to be 'an orange spellbook'
    quoted_spellbook = quote .. type .. quote
  end

  return quoted_spellbook
end


function pick_quote_char(name)
  local quote

  if (string.find(name, "'")) then
    quote = '"'

  elseif (string.find(name, '"')) then
    quote = "'"

  else
    quote = "'"
  end

  return quote
end


function find_index(t, item)
  local res = nil

  for i = 1, #t do
    if (t[i] == item) then
      res = i
      break
    end
  end

  return res
end



-------------------
-- database stuff
-------------------

function dbcheck(code)
 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg()   -- the rollback will change the error message
    db:exec("ROLLBACK")       -- rollback any transaction to unlock the database
    error(err, 2)             -- show error in caller's context
  end
end


function fixsql(s)
  if s then
    return "'" .. (string.gsub(s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end
end


function create_tables()
  -- create table
  dbcheck(db:execute[[
    PRAGMA foreign_keys = ON;
    PRAGMA journal_mode = WAL;

    CREATE TABLE IF NOT EXISTS spellbooks(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      char_name     TEXT NOT NULL,   -- character name
      spell         TEXT NOT NULL,   -- spell name
      spellbook     TEXT NOT NULL,   -- spellbook name
      container     TEXT NOT NULL,   -- container name
      date_added    INTEGER
    );

    CREATE TABLE IF NOT EXISTS mems(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      char_name     TEXT NOT NULL,   -- character name
      spell         TEXT NOT NULL,   -- spell name
      date_added    INTEGER
    );

    CREATE TABLE IF NOT EXISTS mems_sets(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      char_name     TEXT NOT NULL,   -- character name
      set_name      TEXT NOT NULL,   -- mems set name
      spell         TEXT NOT NULL,   -- spell name
      date_added    INTEGER
    );

 ]])
end



---------------------------
-- auto-detect spellbooks
---------------------------

spellbook_types = {
  "an ancient vellum spellbook",
  "an arcane spellbook",
  "the arcane spellbook of power",
  "an atrous spellbook",
  "a battlecaster's spellbook",
  "the Book of Eight",
  "a book of enchantment",
  "a book of spells",
  "a brassbound copy of the Grimoirium Magica",
  "a copper-bound spellbook",
  "a copy of the Grimoirium Magica",
  "a chronomancer's vital spellbook",
  "a dark prayer book",
  "a dark violet prayer book",
  "a dazzling book of the necromancers",
  "a death's head spellbook",
  "a demonologist's practice spellbook",
  "a draconscale spellbook",
  "a gray spellbook",
  "the grease-stained spellbook of Tetrarch Hyksos",
  "a hobgoblin's book of wizardry",
  "an impressive book of the necromancers",
  "the Necronomicon",
  "a Necronomicon bound in fetal elf hide",
  "an ogrehide spellbook",
  "a sandy spellbook",
  "a spellbook bound in black leather",
  "a spellbook bound in blue leather",
  "a spellbook bound in green leather",
  "a spellbook bound in nightblue leather",
  "a spellbook bound in octarine leather",
  "a spellbook bound in orange leather",
  "a spellbook bound in red leather",
  "a spellbook bound in sunburst leather",
  "a spellbook bound in violet leather",
  "a spellbook bound in white leather",
  "a spellbook bound in yellow leather",
  "a spellbook decorated with seashells",
  "the spellbook of the wizard of Focault",
  "a spellbook with an ornate 'K' on the cover",
  "a spellbook with a sunburst leather cover",
  "a sunburst-leather spellbook",
  "a test spellbook: spells P-Z",
  "a test spellbook: spells H-O",
  "a test spellbook: spells A-G",
  "a tome titled, 'Inferno'",
  "a twisted white leatherbound spellbook",
  "Vandemaar's Book of Advanced Magic",
  "Vandemaar's Book of Neophyte Magics",
  "a white leatherbound spellbook",
}


function get_and_auto_detect_spellbooks(container, mode)
  wait.make(function()
    container = string.lower(Trim(container))

    local quoted_container, quoted_spellbook

    quoted_container = quote_container(container)

    local use_types

    if (mode == "by type") then
      use_types = spellbook_types
      Note("-- mems_helper: checking all spellbooks, by type, from " .. container .. "... --")

    else -- mode == "all"
      use_types = { "spellbook" }
      Note("-- mems_helper: checking all spellbooks from " .. container .. "... --")
    end

    container_exists = true

    detected_spellbooks = {}

    EnableTrigger("detect_container", true)
    EnableTrigger("detect_spellbook_type", true)

    for i = 1, #use_types do
      quoted_spellbook = quote_spellbook(_, use_types[i])

      spellbook_type_exists = true

      -- get all spellbooks of a given type
      Send("get all." .. quoted_spellbook .. " " .. quoted_container)

      -- give the trigger time to detect if container / spellbook exist
      wait.time(1)

      if (not container_exists) then
        break
      end

      if (spellbook_type_exists) then
        -- check their spells
        auto_detect_spellbooks(container)

        while (spellbook_exists) do
          wait.time(1)
        end

        -- put spellbooks back into their container
        Send("put all." .. quoted_spellbook .. " " .. quoted_container)
      end
    end

    EnableTrigger("detect_container", false)
    EnableTrigger("detect_spellbook_type", false)

    Note("-- mems_helper: ... done! --")
  end)
end


function no_such_container()
  container_exists = false
end


function no_such_spellbook_type()
  spellbook_type_exists = false
end


function auto_detect_spellbooks(container)
  --all spellbooks to be detected must be in your inventory

  wait.make(function()
    DeleteVariable(name .. "_mems")
    SaveState()

    use_container = string.lower(Trim(container))

    spellbook_exists = true

    local i = 1

    EnableTrigger("detect_spellbook", true)
    EnableTriggerGroup("detect_spells", true)

    Note("-- mems_helper: detecting spells scribed in spellbooks in your inventory --")

    repeat
      Send("look " .. i .. ".spellbook")
      wait.time(1)
      i = i + 1
    until (not spellbook_exists)

    EnableTrigger("detect_spellbook", false)
    EnableTriggerGroup("detect_spells", false)

    use_container = nil
  end)
end


function no_such_spellbook()
  spellbook_exists = false
end


function spellbook_detected(name)
  detected_spellbooks[name] = (detected_spellbooks[name] or 0) + 1

  current_spellbook = name
end


function spells_detected(spells)
  spells = string.gsub(spells, ", ", ",")

  local tspells = utils.split(spells, ",")

  db:exec("BEGIN TRANSACTION;")

  for i = 1, #tspells do
    save_spell(name, use_container, detected_spellbooks[current_spellbook] .. "." .. current_spellbook, tspells[i])
  end

  db:exec("COMMIT;")
end



-------------------------------------
-- save spellbooks info to database
-------------------------------------

function save_spell(char_name, container, spellbook, spell)
  -- this adds stuff in silent mode to avoid spam
  if (not spell_exists(char_name, container, spellbook, spell)) then
    add_spell_to_database(char_name, container, spellbook, spell)
  end
end


function spell_exists(char_name, container, spellbook, spell)
  local res = false

  for row in db:nrows(string.format("SELECT * FROM spellbooks WHERE char_name = %s AND container = %s AND spellbook = %s AND spell = %s", fixsql(name), fixsql(container), fixsql(spellbook), fixsql(spell))) do
    res = true
    break
  end

  return res
end


function add_spell_to_database(char_name, container, spellbook, spell)
  dbcheck(db:execute(string.format(
  "INSERT INTO spellbooks(char_name, container, spellbook, spell, date_added) VALUES(%s, %s, %s, %s, DATETIME('NOW'));",
    fixsql(char_name),
    fixsql(container),
    fixsql(spellbook),
    fixsql(spell)
  )))
end



--------------------------
-- purge spellbooks info
--------------------------

function purge_spellbooks(container)
  container = string.lower(Trim(container))

  DeleteVariable(name .. "_mems")
  SaveState()

  db:exec("BEGIN TRANSACTION;")

  if (container ~= "") then
    Note("-- mems_helper: deleting spellbooks info for container = " .. container .. " from my db --")

    dbcheck(db:execute(string.format(
      "DELETE FROM spellbooks WHERE char_name = %s AND container = %s;", fixsql(name), fixsql(container)
    )))

  else
    Note("-- mems_helper: deleting all spellbooks info from my db --")

    dbcheck(db:execute(string.format(
      "DELETE FROM spellbooks WHERE char_name = %s;", fixsql(name)
    )))
  end

  db:exec("COMMIT;")
end



---------------------------------------------
-- list all scribed spells + their location
---------------------------------------------

function list_all_spellbooks()
  local spellbooks = {}

  for row in db:nrows(string.format("SELECT * FROM spellbooks WHERE char_name = %s", fixsql(name))) do
    if (not spellbooks[row.container]) then
      spellbooks[row.container] = {}
    end

    if (not spellbooks[row.container][row.spellbook]) then
      spellbooks[row.container][row.spellbook] = {}
    end

    table.insert(spellbooks[row.container][row.spellbook], row.spell)
  end

--  ColourNote("silver", "black", serialize.save_simple(spellbooks))
  show_spellbooks(spellbooks)
end


function show_spellbooks(spellbooks)
  Note("-- mems_helper --")
  Note("scribed spells, by container and spellbook: ")

  -- sort the list by container, spellbook, spell
  local tcont = {}
  local tsbook = {}

  for container, list in pairs(spellbooks) do
    if (not find_index(tcont, container)) then
      tcont[#tcont + 1] = container
    end

    for spellbook, spells in pairs(list) do
      if (not find_index(tsbook, spellbook)) then
        tsbook[#tsbook + 1] = spellbook
      end
    end
  end

  table.sort(tcont)
  table.sort(tsbook)

  local spells

  for i = 1, #tcont do
    -- show container
    Tell("* ")
    ColourTell("silver", "black", tcont[i])
    Note(":")

    for j = 1, #tsbook do
      spells = spellbooks[tcont[i]][tsbook[j]]

      if (spells) then
        -- show spellbook
        Tell("  + ")
        ColourTell("silver", "black", tsbook[j])
        Note(":")

        -- show spells
        table.sort(spells)

        for k = 1, #spells do
          Tell("    - ")
          ColourNote("silver", "black", spells[k])
        end
      end
    end
  end

  Note("")
end



------------------------------------
-- locate spellbooks by spell name
------------------------------------

function locate_spellbooks(spell)
  spell = Trim(string.lower(spell))

  local tres = do_locate_spellbooks(spell)

--  ColourNote("silver", "black", serialize.save_simple(tres))
  show_located_spellbooks(spell, tres)

  -- using the first spellbook in the list...

  if (#tres > 0) then
    -- we want to remember the container for whenever we store the spellbooks
    last_container = tres[1].container

    local quoted_container = quote_container(tres[1].container)

    local num, spellbook
    num, spellbook = string.match(tres[1].spellbook, "(.+)%.(.+)")

    -- if it's 4.an orange spellbook, we want to get all.'an orange spellbook'
    local all_spellbooks = quote_spellbook("all", spellbook)

    -- if it's 4.an orange spellbook, we want to hold '4.an orange spellbook'
    spellbook = quote_spellbook(num, spellbook)

    Note("getting and holding the first one in the list")
    Send("get " .. all_spellbooks .. " " .. quoted_container)
    Send("hold " .. spellbook)

    Tell("use '")
    ColourTell("silver", "black", "store spellbooks")
    Note("' to keep proper stacking order and location")
  end
end


function do_locate_spellbooks(spell)
  local tres = {}

  for row in db:nrows(string.format("SELECT * FROM spellbooks WHERE char_name = %s AND spell = %s", fixsql(name), fixsql(spell))) do
    tres[#tres + 1] = {
      container = row.container,
      spellbook = row.spellbook,
    }
  end

  return tres
end


function show_located_spellbooks(spell, tbooks)
  Note("-- mems_helper --")
  Note("spellbooks containing the spell '" .. spell .. "': ")

  for i = 1, #tbooks do
    Tell("+ ")
    ColourTell("silver", "black", tbooks[i].spellbook)
    Tell(" (in ")
    ColourTell("silver", "black", tbooks[i].container)
    Note(")")
  end

  Note("")
end


function store_spellbooks()
  if (last_container) then
    Send("remove all.spellbook")

    local quoted_container = quote_container(last_container)

    Send("put all.spellbook " .. quoted_container)
  end
end



---------------------------------------------------
-- add / delete / list default spells to memorize
---------------------------------------------------

function add_mem(spell)
  spell = string.lower(Trim(spell))

  if (not mem_exists(spell)) then
    DeleteVariable(name .. "_mems")
    SaveState()

    Note("-- mems_helper: adding '" .. spell .. "' to your default mems --")
    add_mem_to_database(name, spell)

  else
    ColourNote("tomato", "black", "-- mems_helper: '" .. spell .. "' is already in your default mems --")
  end
end


function del_mem(spell)
  spell = string.lower(Trim(spell))

  if (mem_exists(spell)) then
    DeleteVariable(name .. "_mems")
    SaveState()

    Note("-- mems_helper: removing '" .. spell .. "' from your default mems --")
    del_mem_from_database(name, spell)

  else
    ColourNote("tomato", "black", "-- mems_helper: '" .. spell .. "' is not in your default mems --")
  end
end


function list_mems()
  local tres = get_mems()

  Note("-- mems_helper --")
  Note("default spells to memorize: ")
--  ColourNote("silver", "black", serialize.save_simple(tres))

  for i = 1, #tres do
    Tell("- ")
    ColourNote("silver", "black", tres[i])
  end
end


function get_mems()
  local tres = {}

  for row in db:nrows(string.format("SELECT * FROM mems WHERE char_name = %s", fixsql(name))) do
    tres[#tres + 1] = row.spell
  end

  table.sort(tres)

  return tres
end


function mem_exists(spell)
  local res = false

  for row in db:nrows(string.format("SELECT * FROM mems WHERE char_name = %s AND spell = %s", fixsql(name), fixsql(spell))) do
    res = true
    break
  end

  return res
end


function add_mem_to_database(char_name, spell)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
  "INSERT INTO mems(char_name, spell, date_added) VALUES(%s, %s, DATETIME('NOW'));",
    fixsql(char_name),
    fixsql(spell)
  )))

  db:exec("COMMIT;")
end


function del_mem_from_database(char_name, spell)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "DELETE FROM mems WHERE char_name = %s AND spell = %s;",
      fixsql(char_name),
      fixsql(spell)
  )))

  db:exec("COMMIT;")
end



--------------------------------------------------
-- add / delete / list spells to / from / in set
--------------------------------------------------

function add_mem_to_set(set, spell)
  set = string.lower(Trim(set))
  spell = string.lower(Trim(spell))

  if (set ~= "default") then
    if (not mem_exists_in_set(set, spell)) then
      Note("-- mems_helper: adding '" .. spell .. "' to your '" .. set .. "' mems set --")
      add_mem_to_set_in_database(name, set, spell)

    else
      ColourNote("tomato", "black", "-- mems_helper: '" .. spell .. "' is already in your '" .. set .. "' mems set --")
    end

  else
    add_mem(spell)
  end
end


function del_mem_from_set(set, spell)
  set = string.lower(Trim(set))
  spell = string.lower(Trim(spell))

  if (set ~= "default") then
    if (mem_exists_in_set(set, spell)) then
      Note("-- mems_helper: removing '" .. spell .. "' from your '" .. set .. "' mems set --")
      del_mem_from_set_in_database(name, set, spell)

    else
      ColourNote("tomato", "black", "-- mems_helper: '" .. spell .. "' is not in your '" .. set .. "' mems set --")
    end

  else
    del_mem(spell)
  end
end


function list_mems_in_set(set)
  set = string.lower(Trim(set))

  local tres
  if (set ~= "default") then
    tres = get_mems_in_set(set)
  else
    tres = get_mems()
  end

  Note("-- mems_helper --")
  Note("spells to memorize in the '" .. set .. "' set: ")
--  ColourNote("silver", "black", serialize.save_simple(tres))

  for i = 1, #tres do
    Tell("- ")
    ColourNote("silver", "black", tres[i])
  end
end


function list_mems_sets()
  local tres = get_list_of_sets()

  Note("-- mems_helper --")
  Note("list of memorization sets: ")
--  ColourNote("silver", "black", serialize.save_simple(tres))

  for i = 1, #tres do
    Tell("= ")
    ColourNote("silver", "black", tres[i])
  end

  Note("(use 'list mems' to see your default set, or 'list mems set:<set_name>' to see a different set)")
end


function get_mems_in_set(set)
  local tres = {}

  for row in db:nrows(string.format("SELECT * FROM mems_sets WHERE char_name = %s AND set_name = %s", fixsql(name), fixsql(set))) do
    tres[#tres + 1] = row.spell
  end

  table.sort(tres)

  return tres
end


function get_list_of_sets()
  local tres = {}

  -- default set?
  local tdefault = get_mems()
  if (#tdefault > 0) then
    tres[#tres + 1] = "default"
  end

  -- other sets
  for row in db:nrows(string.format("SELECT * FROM mems_sets WHERE char_name = %s", fixsql(name))) do
    if (not find_index(tres, row.set_name)) then
      tres[#tres + 1] = row.set_name
    end
  end

  table.sort(tres)

  return tres
end


function mem_exists_in_set(set, spell)
  local res = false

  for row in db:nrows(string.format("SELECT * FROM mems_sets WHERE char_name = %s AND set_name = %s AND spell = %s", fixsql(name), fixsql(set), fixsql(spell))) do
    res = true
    break
  end

  return res
end


function add_mem_to_set_in_database(char_name, set, spell)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
  "INSERT INTO mems_sets(char_name, set_name, spell, date_added) VALUES(%s, %s, %s, DATETIME('NOW'));",
    fixsql(char_name),
    fixsql(set),
    fixsql(spell)
  )))

  db:exec("COMMIT;")
end


function del_mem_from_set_in_database(char_name, set, spell)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "DELETE FROM mems_sets WHERE char_name = %s AND set_name = %s AND spell = %s;",
      fixsql(char_name),
      fixsql(set),
      fixsql(spell)
  )))

  db:exec("COMMIT;")
end



--------------------
-- memorize spells
--------------------

function memorize()
  local mems = GetVariable(name .. "_mems")

  if (first_run)
  or (not mems) or (Trim(mems) == "") then
    mems = make_mems()
    first_run = false

    SetVariable(name .. "_mems", mems)
    SaveState()
  end

  do_mems(mems)
end


function memorize_set(set)
  set = string.lower(Trim(set))

  if (set ~= "default") then
    local mems = make_mems(set)
    do_mems(mems)

  else
    memorize()
  end
end


function make_mems(set)
  Note("-- mems_helper: reworking your memorization sequence --")
  -- what to mem
  local tmems
  if (set) then
    tmems = get_mems_in_set(set)
  else
    tmems = get_mems()
  end

  -- search spells locations & sort them
  local to_mem, sorted_mems
  to_mem, sorted_mems = locate_n_sort_mems(tmems)

  local tres = make_mems_sequence(to_mem, sorted_mems)

  local res = table.concat(tres, ";")

  if (GetAlphaOption("command_stack_character") == ";") then
    res = string.gsub(res, ";", ";;");
  end

  return res
end


function locate_n_sort_mems(tmems)
  local to_mem = {}
  local sorted_mems = {}

  local tbooks

  for i = 1, #tmems do
    tbooks = do_locate_spellbooks(tmems[i])

    if (#tbooks > 0) then
      local container = tbooks[1].container
      local book = tbooks[1].spellbook

      if (not to_mem[container]) then
        to_mem[container] = {}
      end

      if (not to_mem[container][book]) then
        to_mem[container][book] = {}
      end

      table.insert(to_mem[container][book], tmems[i])

      if (not find_index(sorted_mems, container .. ":" .. book)) then
        sorted_mems[#sorted_mems + 1] = container .. ":" .. book
      end
    end
  end

  table.sort(sorted_mems)

  return to_mem, sorted_mems
end


function make_mems_sequence(to_mem, sorted_mems)
  local tres = {}

  local container, book, old_container, old_type, num, type, quoted_container, quoted_spellbooks

  old_type = ""
  old_container = ""

  if (#sorted_mems > 0) then
    tres[#tres + 1] = "mem purge"
  end

  for i = 1, #sorted_mems do
    container, book = string.match(sorted_mems[i], "(.+):(.+)")

    num, type = string.match(book, "(.+)%.(.+)")

    if ((container .. ":" .. type) ~= (old_container .. ":" .. old_type)) then
    -- spellbook type and / or container changed

      if (old_container ~= "") and (old_type ~= "") then
      -- old container and old_type exist, so we need to store spellbooks

        quoted_container = quote_container(old_container)
        quoted_spellbooks = quote_spellbook("all", old_type)

        tres[#tres + 1] = "put " .. quoted_spellbooks .. " " .. quoted_container
      end

      -- get all the new type of spellbooks from the new container
      quoted_container = quote_container(container)
      quoted_spellbooks = quote_spellbook("all", type)

      tres[#tres + 1] = "get " .. quoted_spellbooks .. " " .. quoted_container

      old_container = container
      old_type = type
    end

    -- hold the new spellbook
    quoted_spellbooks = quote_spellbook(num, type)

    tres[#tres + 1] = "hold " .. quoted_spellbooks

    -- memorize needed spells in the current spellbook
    for j = 1, #to_mem[container][book] do
      local spell = to_mem[container][book][j]

      tres[#tres + 1] = "mem '" .. spell .. "'"
    end

    -- remove the spellbook
    quoted_spellbooks = quote_spellbook(_, type)

    tres[#tres + 1] = "rem " .. quoted_spellbooks
  end

  -- store the last set of spellbooks used
  if (old_type ~= "") and (old_container ~= "") then
    quoted_container = quote_container(old_container)
    quoted_spellbooks = quote_spellbook("all", old_type)

    tres[#tres + 1] = "put " .. quoted_spellbooks .. " " .. quoted_container
  end

  return tres
end


function do_mems(mems)
  ColourNote("silver", "black", mems)

  if (mems ~= "") then
    Note("-- mems_helper: trying to execute your memorization sequence --")

    do_sequence(mems)

  else
    ColourNote("tomato", "black", "-- mems_helper: nothing to mem! --")
  end
end


function do_sequence(seq)
  if (sequencer_present) then
    Execute("sequence commands " .. seq)

  else
    ColourNote("tomato", "black", "-- mems_helper: the sequencer plugin isn't installed / enabled --")
  end
end


function purge_set(set)
  set = string.lower(Trim(set))

  local seq = make_purge_sequence(set)

  ColourNote("silver", "black", seq)

  if (seq ~= "") then
    Note("-- mems_helper: trying to execute your memorization purge sequence --")

    do_sequence(seq)

  else
    ColourNote("tomato", "black", "-- mems_helper: nothing to purge! --")
  end
end


function make_purge_sequence(set)
  Note("-- mems_helper: reworking your memorization purge sequence --")

  local tpurges
  if (set ~= "default") then
    tpurges = get_mems_in_set(set)
  else
    tpurges = get_mems()
  end

  local tseq = {}

  for i = 1, #tpurges do
    tseq[#tseq + 1] = "mem '" .. tpurges[i] .. "'"
  end

  return table.concat(tseq, ";")
end



-------------------------
-- mems complexity calc
-------------------------

function calc_mem_cmplx()
  complexities = {}
  EnableTriggerGroup("detect_cmplx", true)

  Note("-- mems_helper: sending 'skills spells' to capture your spells complexities --")
  Send("skills spells")
end


function auto_cont()
  SendNoEcho("C")
end


function process_spell(spell, cmplx)
  complexities[spell] = tonumber(cmplx)
end


function end_of_spells_list()
  EnableTriggerGroup("detect_cmplx", false)

  memmed_spells = {}

  EnableTriggerGroup("detect_mems", true)

  Note("-- mems_helper: sending 'memorize' to capture your memorized spells --")
  Send("memorize")
end


function memmed_spells_line(spell1, spell2)
  memmed_spells[#memmed_spells + 1] = spell1

  if (spell2 ~= "") then
    memmed_spells[#memmed_spells + 1] = spell2
  end
end


function calc_mems()
  EnableTriggerGroup("detect_mems", false)

  local res = 0

  for i = 1, #memmed_spells do
    local spell = memmed_spells[i]

    local cmplx = complexities[spell] or 0

    res = res + cmplx
  end

  Note("-- mems_helper --")
  Tell("total mems complexity: ")
  ColourTell("silver", "black", res)
end



-----------------------------
-- interface with sequencer
-----------------------------

function sequencer_plugin_present()
  return is_plugin_present("sequencer", "7daf1d7890d9db73d74a8188")
end


]]>

</script>

</muclient>
