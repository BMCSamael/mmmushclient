<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, April 14, 2013, 10:08 AM -->
<!-- MuClient version 4.90 -->

<!-- Plugin "sort_container" generated by Plugin Wizard -->

<muclient>

<plugin
   name="sort_container"
   author="Ruthgul"
   id="60a4b5df5d7507d9ec3d2d7a"
   language="Lua"
   purpose="helps get rid of random junk in a container"
   date_written="2013-04-14 10:06:37"
   date_modified="2014-04-11 09:15:10"
   requires="4.71"
   version="1.0"
   >

<description trim="y">

<![CDATA[

.------------------.
 | sort_container |
`------------------'

- It lists a container's items in alphabetical order.
- It helps discard chosen items in a container.
- It remembers your choices for future uses.


** REQUIRES **

- MM_GMCP_Handler (plugin id="f67c4339ed0591a5b010d05b") must be installed and enabled.
- detect_globals (plugin id="d900cb999816b1f6f2d4bdc5") must be installed and enabled.
- global_vars (plugin id="97784abf5f30629a0d7e7307") must be installed and enabled.


Syntax:

* list container <container_name>  - lists the container's items in alphabetical order (Note it won't show an item's invisible/worn/etc. status.)

* sort container <container_name>  - shows a dialog to pick which items from the container you want to drop, then it gets them from the container and drops them


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Aliases  -->

<aliases>

  <alias
   enabled="y"
   match="^list container (?P&lt;container&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>list_container("%&lt;container&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^sort container (?P&lt;container&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if (name) then
  sort_container("%&lt;container&gt;")
else
  plugin_not_initialized()
end
</send>
  </alias>

<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^sort\_container(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Triggers  -->

<triggers>

<!-- on first prompt -->

  <trigger
   enabled="y"
   name="first_prompt"
   keep_evaluating="y"
   match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)|\&gt;) $"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>on_first_prompt()
</send>
  </trigger>


<!-- auto-continue -->

  <trigger
   name="continue"
   keep_evaluating="y"
   match="^\[C\]ontinue \[R\]edraw \[B\]ack \[E\]xit\: $"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>auto_cont()
</send>
  </trigger>


<!-- detect items -->

  <trigger
   name="container_none"
   keep_evaluating="y"
   match="^(You do not see that here|That\'s not something in which you can look\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>no_such_container()
</send>
  </trigger>

  <trigger
   name="container_start"
   keep_evaluating="y"
   match="^(.+) contains\:$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>start_container()
</send>
  </trigger>

  <trigger
   name="container_line"
   keep_evaluating="y"
   match="^[ ]*(|\([ ]*(?P&lt;num&gt;[0-9]+)\)) (|\(Invisible\) )(?P&lt;name&gt;[^\(^\)]+)(| \(.+\))$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>item_container("%&lt;num&gt;", "%&lt;name&gt;")
</send>
  </trigger>

  <trigger
   name="container_end"
   keep_evaluating="y"
   match="^A total of (.+) \((.+) max\) item(|s) weighing (.+) st(|s)\, (.+) pb(|s) \((.+) st(|s)\, (.+) pb(|s) max\)\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
end_container()
</send>
  </trigger>


<!-- detect drop -->

  <trigger
   name="detect_drop"
   keep_evaluating="y"
   match="^You drop (?P&lt;item&gt;.+)\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>dropped_something("%&lt;item&gt;")
</send>
  </trigger>


<!-- detect can't get / drop -->

  <trigger
   group="detect_cant_drop"
   keep_evaluating="y"
   match="^You can\'t let go of it\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>item_is_no_drop()
</send>
  </trigger>


  <trigger
   group="detect_cant_drop"
   keep_evaluating="y"
   match="^(.+)\: you cannot carry that much weight\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>item_is_too_heavy()
</send>
  </trigger>


  <trigger
   group="detect_cant_drop"
   keep_evaluating="y"
   match="^(.+)\: there\'s not enough room in your inventory\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>inventory_is_full()
</send>
  </trigger>


  <trigger
   group="detect_cant_drop"
   keep_evaluating="y"
   match="^There\'s no room to drop (.+) here\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>room_is_full()
</send>
  </trigger>

</triggers>



<!--  Scripts  -->

<script>

<![CDATA[

require "wait"
require "serialize"

debug = false


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  Tell("-- " .. GetPluginInfo(GetPluginID (), 1) .. ": type ")
  ColourTell("silver", "black", GetPluginInfo(GetPluginID (), 1) .. " help")
  Note(" to see info about this plugin --")

  -- open database on disk
  db = assert(sqlite3.open(GetInfo(66) .. "sort_container.db"))

  create_table()    -- create database structure if necessary

  EnableTrigger("first_prompt", true)
  name = nil
end


function OnPluginConnect()
  EnableTrigger("first_prompt", true)
  name = nil
end


function OnHelp ()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID (), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo (GetPluginID(), 14)) .. ")")
end


function plugin_not_initialized()
  Note("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": plugin initialization unfinished --")
  Note("please wait 5 seconds and try again")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/sort_container.xml",
  }
  return (table.concat(t, ";"))
end



------------------
-- general stuff
------------------

function on_first_prompt()
  wait.make(function()
    EnableTrigger("first_prompt", false)

    -- give the plugins time to initialize
    wait.time(3)

    do_get_name()
  end)
end


function OnPluginBroadcast(msg, id, pname, text)
  if (id =="97784abf5f30629a0d7e7307")
  and (pname == "global_vars") then -- global_vars
    if (msg == 1) and (text == "name") then
      -- name broadcasted
      do_get_name()
    end
  end
end


function do_get_name()
  name = get_global_var("name")
end


function get_global_var(name)
  local res, val

  res, val = CallPlugin("97784abf5f30629a0d7e7307", "get_global_var", name)

  if (res ~= 0) then
    val = nil
  end

  return val
end


function auto_cont()
  SendNoEcho("C")
end



-------------------
-- database stuff
-------------------

function dbcheck(code)
 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg()   -- the rollback will change the error message
    db:exec("ROLLBACK")       -- rollback any transaction to unlock the database
    error(err, 2)             -- show error in caller's context
  end
end


function fixsql(s)
  if s then
    return "'" .. (string.gsub(s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end
end


function create_table()
  -- create table
  dbcheck(db:execute[[
    PRAGMA foreign_keys = ON;
    PRAGMA journal_mode = WAL;

    CREATE TABLE IF NOT EXISTS junk(
      id            INTEGER PRIMARY KEY AUTOINCREMENT,
      char_name     TEXT NOT NULL,   -- character name
      item_name     TEXT NOT NULL,   -- item name
      date_added    INTEGER
    );
 ]])
end


function load_choice_from_database(item)
  local discard = 0

  for row in db:nrows(string.format("SELECT * FROM junk WHERE char_name = %s AND item_name = %s ", fixsql(name), fixsql(item))) do
    discard = 1
  end

  return discard
end


function save_choice(item, choice)
  if (choice) then
    save_choice_to_database(item)

  else
    delete_choice_from_database(item)
  end
end


function save_choice_to_database(item)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "INSERT INTO junk(char_name, item_name, date_added) VALUES(%s, %s, DATETIME('NOW'));",
      fixsql(name),
      fixsql(item)
  )))

  db:exec("COMMIT;")
end


function delete_choice_from_database(item)
  db:exec("BEGIN TRANSACTION;")

  dbcheck(db:execute(string.format(
    "DELETE FROM junk WHERE char_name = %s AND item_name = %s;",
      fixsql(name),
      fixsql(item)
    )))

  db:exec("COMMIT;")
end



------------------------
-- list and sort stuff
------------------------

function no_such_container()
  EnableTrigger("continue", false)
  EnableTrigger("container_none", false)
  EnableTrigger("container_start", false)
  tcont = nil
  done = true
end


function start_container()
  EnableTrigger("container_start", false)
  EnableTrigger("container_line", true)
  EnableTrigger("container_end", true)
  tcont = {}
  done = false
end


function item_container(num, item)
  item = Trim(item)

  num = tonumber(num)
  if (not num) then
    num = 1
  end

  if (not tcont[item]) then
    tcont[item] = num
  else
    tcont[item] = tcont[item] + num
  end
end


function end_container()
  EnableTrigger("continue", false)
  EnableTrigger("container_line", false)
  EnableTrigger("container_end", false)
  done = true

  if (do_list) and (tcont) then
    do_show_items()
    show_original_line()
  end

  if (debug) then
    Note(serialize.save_simple(tcont))
  end
end


function show_original_line()
  for i = 1, #trigger_style_runs do
    ColourTell(RGBColourToName(trigger_style_runs[i].textcolour),
               RGBColourToName(trigger_style_runs[i].backcolour),
               trigger_style_runs[i].text)
  end
end



-------------------
-- list container
-------------------

function list_container(cont)
  if (not working) then
    do_list = true
    EnableTrigger("continue", true)
    EnableTrigger("container_none", true)
    EnableTrigger("container_start", true)
    SetTriggerOption("container_line", "omit_from_output", "y")
    SetTriggerOption("container_end", "omit_from_output", "y")
    SetTriggerOption("container_end", "send_to", "14")

    Send("look in '" .. cont .. "'")

  else
    Note("-- sort_container: script already running! --")
  end
end


function do_show_items()
  local keys = {}

  for item, num in pairs(tcont) do
    keys[#keys +1] = item
  end

  table.sort(keys, function(i1, i2)
                     return make_sortable(i1) < make_sortable(i2)
                   end)

  for i = 1, #keys do
    if (tcont[keys[i]] == 1) then
      Tell("      ")

    else
      Tell("(" .. string.rep(" ", 3 - string.len(tostring(tcont[keys[i]]))) .. tcont[keys[i]] .. ") ")
    end

    ColourNote("silver", "black", keys[i])
  end
end


function make_sortable(item)
  item = string.lower(item)
  item = string.gsub(item, "^a ", "")
  item = string.gsub(item, "^an ", "")
  item = string.gsub(item, "^the ", "")

  return item
end



-------------------
-- sort container
-------------------

function sort_container(cont)
  wait.make(function()
    if (not working) then
      EnableTrigger("container_none", true)
      EnableTrigger("container_start", true)
      SetTriggerOption("container_line", "omit_from_output", "n")
      SetTriggerOption("container_end", "omit_from_output", "n")
      SetTriggerOption("container_end", "send_to", "12")
      Send("look in '" .. cont .. "'")

      repeat
        wait.time(.5)
      until (done)

      if (tcont) then
        pick_items()

        repeat
          wait.time(.5)
        until (done)

        do_sort(cont)
      end

    else
      Note("-- sort_container: script already running! --")
    end
  end)
end


function pick_items()
  done = false

  tpicks = {}

  repeat
    local choices = {}

    -- build table of choices, with existing values
    for item, amount in pairs(tcont) do
      local val = load_choice(item)

      local yes_no = "No"
      if (val == 1) then
        yes_no = "Yes"
      end

      choices[item] = string.format("%s x %i (%s)", item, tcont[item], yes_no)
    end

    -- choose one ...
    local result = utils.listbox("Choose an option to edit.\r\n\r\nClick OK or Cancel when done (any changes will be retained).", "Options", choices)

    -- if not cancelled, go to appropriate handler
    if (result) then
      toggle_option(result)
    end
  until not result -- loop until dialog cancelled

  if (debug) then
    Note(serialize.save_simple(tpicks))
  end

  done = true
end


function load_choice(item)
  res = 0

  if (tpicks[item]) then
    res = 1

  else
    res = load_choice_from_database(item)
    if (res == 1) then
      tpicks[item] = 1
    end
  end

  if (debug) then
    Note("item: " .. item .. ", choice: " .. as_txt(res))
  end

  return res
end


function toggle_option(item)
  if (debug) then
    Tell("changed: " .. item .. " - from " .. as_txt(tpicks[item] or 0))
  end

  if (tpicks[item] == 1) then
    tpicks[item] = nil

  else
    tpicks[item] = 1
  end

  if (debug) then
    Note(" to " .. as_txt(tpicks[item] or 0))
  end

  save_choice(item, tpicks[item])
end


function as_txt(num)
  local res

  if (num == 0) then
    res = "keep"
  elseif (num == 1) then
    res = "drop"
  end

  return res
end


function do_sort(cont)
  wait.make(function()
    working = true

    for item, _ in pairs(tpicks) do
      if (not working) then
        break
      end

      local num = tcont[item]
--      Note(num)

      for i = 1, num do
        if (not working) then
          break
        end

        dropped = false
        check_dropped = item
        EnableTrigger("detect_drop", true)
        EnableTriggerGroup("detect_cant_drop", true)

        local quote = pick_quote_char(item)
        local quote_cont = pick_quote_char(cont)

        local get_cmd = "get " .. quote .. item .. quote .. " " .. quote_cont .. cont .. quote_cont
        drop_cmd = "drop " .. quote .. item .. quote

        if (not debug) then
          Send(get_cmd)
          Send(drop_cmd)
          repeat
            wait.time(.5)
          until (dropped) or (not working)

        else
          Note(get_cmd)
          Note(drop_cmd)
        end
      end
    end

    working = false
  end)
end


function pick_quote_char(name)
  local quote

  if (string.find(name, "'")) then
    quote = '"'

  elseif (string.find(name, '"')) then
    quote = "'"

  else
    quote = "'"
  end

  return quote
end


function dropped_something(item)
  item = Trim(item)

  if (item == check_dropped) then
    EnableTrigger("detect_drop", false)
    EnableTriggerGroup("detect_cant_drop", false)
    dropped = true
  end
end


function item_is_no_drop()
  Note("-- sort_container: the item can't be dropped, skipping it --")
  EnableTrigger("detect_drop", false)
  EnableTriggerGroup("detect_cant_drop", false)
  dropped = true
end


function item_is_too_heavy()
  Note("-- sort_container: the item is too heavy, skipping it --")
  EnableTrigger("detect_drop", false)
  EnableTriggerGroup("detect_cant_drop", false)
  dropped = true
end


function inventory_is_full()
  Note("-- sort_container: your inventory is full! - please free some space then try again --")
  working = false
end


function room_is_full()
  Note("-- sort_container: the room is full, please move to another room to proceed --")
end



---------------
-- gmcp stuff
---------------

function OnPluginBroadcast(msg, id, name, text)
  if (id =="f67c4339ed0591a5b010d05b") then -- GMCP message
    if (text == "room.info") then -- room.info
      if (working) and (not dropped) then
        Send(drop_cmd)
      end
    end
  end
end


]]>

</script>

</muclient>
